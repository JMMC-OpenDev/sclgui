echo ==== ./README
cat << %%END%% > ./README
SIMBAD client routines.                                                   V 3.3

F. Ochsenbein - M. Wenger                                           27-Jun-1995

===============================================================================

Files contained in this package:

README          This file. It contains the list of the files in the package
                and the history of the successive release.

SIMCLI.DOC      Description of the client routines. These routines are
                used to develop client applications.

Makefile        Typing 'make', it builds the SIMBAD client routines library:
                     libsimcli.a
                and all the demo programmes.

skio.c          Low level socket i/o routines

skclient.c      Low level socket management routines. Client side.

uifclient.c     SIMBAD command level interface routines

simcli.c        SIMBAD query & data level interface routines.

cliopt.c        Function used by the demo programmes. It queries for the
                username and password if they are not provided on the command
                line.

clitest.c       Demo pgm #1
                Returns all data for several predefined queries.
                Uses all routines defined in the package.
                The queries can be overriden by any other one.

clibib.c        Demo pgm #2
                Returns references for several predefined objects.
                These objects can be overriden by any other one.

cliname.c       Demo pgm #3
                Gives a simple example of how a name resolver can be written.

clicoord.c      Demo pgm #4
                Returns just the coordinates for a given object name.

clitime.c       Demo pgm #5
                Queries 500 objects. Displays one dot for each queried object.
                Gives an idea of how fast the client/server works.
                The needed elapsed time is displayed.


Release history:
===============
Release 3.3  -  Jun, 27th 1995

- ANSI C version

- Documentation modification: all the different comment fields are
  described as they are given when they exist.

-----------------------------------------------------------------------------
Release 3.2  -  Feb, 2nd 1995

- Fixes several bugs concerning empty results and display of bibliographical
  references. New socket interface routines.

-----------------------------------------------------------------------------
Release 3.1  -  Mar, 1st 1994

- Checks for a normal SIMBAD userid/password for any connection.
  Another check is made by the server on the version number of the client 
  routine. Connections initiated by clients no longer supported by the server
  will be refused.

- All the demo programmes need a true userid/password. They can be typed on
  the command line (Ex: clitest userid passwd), or, if not, they will be
  prompted (Ex: if you type "clitest userid", only the password will be asked
  for by a prompt).

- A service routine cliopt.c deals with querying the user for his userid and
  password in the demo programmes.

- Accepts queries near objects:
      simbad_query(hh,"~ident","") ;

- Accepts queries by galactical or ecliptical coordinates:
      simbad_query(hh,"g=gal. coord.","") ;
      simbad_query(hh,"e=ecl. coord.","") ;

- Accepts lines of any length. Especially the JP11 measurements are available

- clitime demo programme gives elapsed times.

-----------------------------------------------------------------------------
Release 2.0  -  Sept 28th, 1993

- Improvement of the server stability

- Suppression of signal capture in the client routines

- simbad_query() can be called with only options, leaving the 'question'
  parameter empty.

- there is a new demo programme: clibib

-----------------------------------------------------------------------------
Release 1.1  -  July 20, 1993

- Improvement of the client application/server interactions: the server is
  more immune against crashes of a client application.

- New data available: 
  the measurements are now available, with two limitations:
     JP11 is not available
     IRAS is available, without the reference field.

- New astrotype: 
     I.0 gives a selected identifier.

- The option field in simbad_query() can be used for:
     * defining a radius when querying by coordinates
     * limiting bibliography between years

- Error management:
  All client routines return -1 or NULL when an error is encountered.
  The actual error is accessible through two functions:
     * simbad_errno() returns a general error code.
     * simbad_error() returns the text of the error message
  No error text is directly printed by the routines.

-----------------------------------------------------------------------------
Release 1.0  -  June 18, 1993

First distributed release.

-----------------------------------------------------------------------------
%%END%%
echo ==== ./SIMCLI.DOC
cat << %%END%% > ./SIMCLI.DOC
================================================================================
                        SIMBAD client routines
                            F. Ochsenbein
                              M. Wenger
                      Release 3.3  -  June 27th, 1995
================================================================================

The aim of this package is to provide a set of routines allowing to
write applications having access to SIMBAD data through the network in
a client/server mode.

A SIMBAD server process is running on the SIMBAD machine, waiting for
clients. These clients send commands and get the queried data returned
through UNIX sockets.

Different routines are used to manage the connection itself, the queries
and the returned data.

This package is in a test phase and should not be distributed for the
moment.

Modifications history is in the file README

New lines in this file are marked by a '*' in the first column.
-------------------------------------------------------------------------------

1) Connection/disconnection:
===========================

  a) Connection
  -------------

  int handle = simbad_connect(char *simbad_node, char *service, 
                                                  char *userid, char *password)
  simbad_node: defines which simbad node to use
               "" for the default node provided in the routine
               THIS SHOULD NOT BE SET DIFFERENTLY FROM "" WITHOUT CDS REQUEST
  service:     defines the service number
               "" for the default service provided in the routine
               THIS SHOULD NOT BE SET DIFFERENTLY FROM "" WITHOUT CDS REQUEST
  userid:      should be a standard SIMBAD userid.
               This parameter is mandatory.
  password:    is the password corresponding to the SIMBAD userid.
               This parameter is mandatory.
  handle:      to be used in the other routines
                        -1 in case of error.

  Example:     hh = simbad_connect("","","your-userid","your-password") ;


  b) Disconnection
  ----------------

  int status = simbad_disconnect(int handle)
  handle:      returned by simbad_connect

  Example:     simbad_disconnect(hh) ;


2) Simbad Query will be achieved within loops:
=============================================

   a. Send the question to Simbad
   ------------------------------

      int nitems = simbad_query(int handle, char *question, char *options)

        handle:   returned by simbad_connect
        question: can be one of the following:
                    - object designation (identifier)
                    - ~ident : for query around this identifier.
                      (cooradius option can be used to define the search radius)
                    - coordinates: equatorial coordinates
                                   galactical coordinates (prefixed by g=)
                                   ecliptical coordinates (prefixed by e=)
                    - bibliographical reference code (it is case insensitive)
                    - filter (NOT YET IMPLEMENTED)
                    - an empty string (""), allowing to send only an 
                      option string.
        options:  They are made of a string containing items separated by ';'.
                  Each item has the format: optionname=value
                  Already available options are:
                     cooradius=radius             for queries by coordinates
                     bibyears=low_year/high_year  for year restriction on bibl.
        nitems:   number of objects existing in Simbad which match the question 
                    0    if none
                         This value is returned if the question string is empty.
                   -1    if error. In that case, an error message is returned
                                   by the function simbad_error(hand)

        Examples: 
           nb = simbad_query(hh,"sirius","") ;
           nb = simbad_query(hh,"~hd 1","cooradius=1");
           nb = simbad_query(hh,"12 34 +56 11",
                                "cooradius=0 20;bibyears=1980/1993");
           nb = simbad_query(hh,"g=123.4-45.3","");
           nb = simbad_query(hh,"1994aj.107.1t","");


   b. Retrieve one of the objects in the list
   ------------------------------------------

      int found = simbad_retrieve(int handle, int number)

        handle:   returned by simbad_connect
        number:   number of objects to look at (0 <= number <= nitems)
                  A value of zero asks for the next object.
        found:    number of objects remaining in the list (including the
                  current one), 0 for no more, -1 for error
                  in case of random object selection, the returned value
                  is the number remaining until the end.

        Example:  i = simbad_retrieve(hh,0) ;


   c. Retrieve which individual data are available for one object
   --------------------------------------------------------------
      
       char *astrotypes = simbad_telldata(int handle)

        handle:     returned by simbad_connect
        astrotypes: blank-separated list of astrotypes for which one
                    or more values can be retrieved. The items
                    can be scanned by e.g. strtok(). 
                    See the "astrotypes" appendix for a list of all defined
                    types and the data formats.
                    Ex. of a possible string: "C J M.B M.V S I"
                        for an object having a type, coordinates, blue and
                        visual magnitude, spectral type and identifiers.

        Example:    atypes = simbad_telldata(hh) ;


   d. Retrieve individual data for one object
   ------------------------------------------

      int ndata = simbad_findata(int handle, char *astrotype, char *option)

        handle:    returned by simbad_connect
        astrotype: specifies the data we want to retrieve, 
                    see the "astrotypes" appendix.
        option:    further parametrisation/restrictions to astrotype, TBD
                   See also simbad_query() for options definition.
        ndata:     tells how many data exist of specified astrotype

        Example:   ndata = simbad_findata(hh,"B","") ;


   e. Retrieve finally the data
   ----------------------------

      char *value = simbad_getdata(int handle, int number)

        handle:    returned by simbad_connect
        number:    the number of the datum to look at (0 <= number <= ndata),
                   value 0 asking for the next
        value:     result as a character string
                   empty string ("") for no data,
                   NULL for error

        Example:   datastr = simbad_getdata(hh,0) ;
        

   f. Get the error code and message
   ----------------------------------

      When an error occurs, the client routines return -1 or NULL (for
      simbad_telldata() and simbad_getdata()). The actual error can be
      retrieved through these two functions:

      int num = simbad_errno(int hand)

        handle:    returned by simbad_connect()
        num:       The error code. Values are:
                       1      network error
                       2      server error
                       3      client error
                      11      simbad error


      char *text = simbad_error(hand)

        handle:    returned by simbad_connect()
        text:      string containing the error message
                   It may be several lines, separated by '\\n' chars.



Example:

   A typical session to get the positions and the designations of the 
   objects around a given position would look like:

        handle = simbad_connect(node, service, user, passwd);
        ...

        nobj = 0 ;
        nitems = simbad_query (handle, "05 12 -72 30", "");
        while (nitems-- > 0) 
        {
            while (simbad_retrieve(handle, 0) == 1)  /* Next Object in list */
            {
               printf("Object #%d: ", ++nobj);
               simbad_findata(handle, "J", ""); 
               puts(simbad_getdata(handle, 1)); /* Print coordinates */
               nid = simbad_findata(handle, "I", "");
               while (nid-- > 0) 
                  printf("  %s\\n", simbad_getdata(handle, 0));
            }
        }
        ...

        simbad_disconnect(handle);


3) A special command would allow to get the most up-to-date definitions
   concerning the various specifiers  ("astrotypes") for simbad_findata
==================================

   int status = simbad_getinfo(int handle, char *question, char *option)

   NOT YET IMPLEMENTED.





Appendix I: Preliminary list of astrotypes
===========================================

   **************************************************
   ******** NOTICE THAT THIS LIST WILL CHANGE *******
   **************************************************


code           definition                           format
------------------------------------------------------------------------------

"C"     object classification (type)      Ascii string. max 15 chars
                                          shorter abbreviations may be defined
                                          Ex: C PulsV*WVir


"J"     B2000 coordinates                 Decimal degrees with precision code:
        In some future: J2000.            AAA.AAAAAAA sDD.DDDDDDD (P)
                                           P = 0    degree
                                               1    1/10th of degree
                                               2    minute
                                               3    1/10th of minute
                                               4    second
                                               5    1/10th of second
                                               6    1/100th of second
                                               7    1/1000th of second
                                          Ex: J  37.9118839 +89.2643200 (6)


"M.B"   Blue magnitude                    MM.mmm:DVn
                                           flags:   ':'  not homogenized to UBV
                                                    'D'  joint magn. in a 
                                                         multiple system
                                                    'V'  variable magnitude.
                                                    n=1  amplitude of 1/100 mag
                                                      2  amplitude of 1/10 mag
                                                      3  amplitude of 1 mag
                                                      4  amplitude > 1 mag
                                                      ?  suspected variable
                                          Ex: M.B  2.62  V1


"M.V"   Visual magnitude                  MM.mmm:DVn
                                           Same flags as "M.B"
                                          Ex: M.V  2.02  V1


"S"     Spectral class                    Ascii string (max: 36 chars)
        (only for stars)                  Ex: S F7:Ib-IIvar


"T"     Morphological classification      Ascii string (max: 36 chars)
        (only for galaxies)               Ex: T Sb


"P"     Proper motions                    +pp.ppp  [ssss]  +pp.ppp  [ssss]
        (only for stars)                  (mua.cos.d  err   mudelta   err )
                                          Unit in arcsec/year, for both r.a. &
                                          dec. Errors are in 1/1000arcsec/year
                                          Ex: P  +0.046  [  25]   -0.004  [  25]


"D"     Dimensions                        dd.dd  r.rr aaa (i)
        for galaxies: log(D25) log(R25)   lD25   lR25  pa  (incl. code)
                                          Ex: D  3.13  0.36  35 (6)


"I"     Identification (alias)            Ascii string. 
                                          Max non definitive: 40 chars
                                          Ex: I GEN# +1.00008890A


"I.0"   Selected identification           Ascii string
                                          Max non definitive: 40 chars
                                          Ex: I.0 HD 123456


"O.cat" Measurements                      Ascii strings
        'cat' stands for the catalogue    There is one line per measurement.
        name of the measurements.         The first line is always the header
        Available catalogs are:           line, describing the records.
        CEL,GCRV,GEN,GJ,HBET,HGAM,IRAS,   Max length: 205 bytes (may change).
        IRC,JP11,MK,PLX,PM,POS,ROT,RVEL,  A complete description of the measu-
        SAO,TD1,UBV,UVBY,VAR,Z            rements can be found in the SIMBAD
                                          user's guide, appendix F.


"B"     Bibliographical code              YYYYJJJJJVVVVMPPPPL
                                          (see 14.4.1, user's guide 1.2)
                                          Ex: B 1987ApJ...315...28H


"R.R"   Bibliographical code              Same as "B"


"R.A"   Bib. ref: author list             Ascii string. Max around 600 chars ?
                 Ex: R.A HARWIT M., HOUCK J.R., SOIFER B.T. and PALUMBO G.G.C.


"R.J"   Bib. ref: journal identification  Ascii string. Max around 300 chars ?
                 Ex: R.J Astrophys. J., 315, 28-45 (1987)


"R.T"   Bib. ref: article title           Ascii string. Max around 600 chars ?
                 Ex: R.T The most luminous far-infrared extragalactic sources.

"R.E"   Bib. ref: erratum                 Ascii string. Max around 100 chars ?

"R.X"   Bib. ref: commentary              Ascii string. Max around 100 chars ?

"R.I"   Bib. ref: flags (abstract,table)  Ascii string. Max around 100 chars ?

"R.F"   Bib. ref: CDS files availability  Ascii string. Max around 100 chars ?

"R.C"   Bib. ref: Dictionary comment      Ascii string. Max around 100 chars ?

================================================================================

%%END%%
echo ==== ./Makefile.distrib
cat << %%END%% > ./Makefile.distrib
#++++++++++++++++
#.IDENTIFICATION Makefile
#.LANGUAGE       Make (makefile script)
#.AUTHOR         Marc Wenger, Francois Ochsenbein [CDS]
#.ENVIRONMENT    Unix
#.KEYWORDS       SIMBAD Client
#.VERSION  220   20-Jun-1995
#.PURPOSE        (Re)Create dependent files in this Directory
#.COMMENTS       
#----------------

SHELL=/bin/sh
RANLIB = /bin/ranlib
#MACHINE=local

# Defaut rule (e.g. copy from a public directory)
.DEFAULT:

# Programs (note the CLIBS required on Solaris):
#-------------------------------------------------
CC     = cc
CINCL  = -I.
CFLAGS = -O -DNODELAY
#CLIBS  = -lsocket -lnsl

# Files:
OBJ = simcli.o uifclient.o cliopt.o skclient.o skio.o
LIB = libsimcli.a
PGM = clitest clibib cliname clicoord clitime clifct 
#
.SUFFIXES: .o .c
.c.o:
	\$(CC) \$(CFLAGS) \$(CINCL) -c \$<
#
all: \$(LIB) \$(PGM)

#
\$(LIB): \$(OBJ)
	ar sruv \$@ \$(OBJ)
	if [ -s \$(RANLIB) ] ; then \$(RANLIB) \$@ ; fi
#
\$(PGM): \$\$@.o \$(LIB)
	\$(CC) \$@.o \$(LIB) \$(CLIBS) -o \$@
#
clean:
	rm -f \$(PGM) \$(LIB) *.o core
%%END%%
echo ==== ./simcli.h
cat << %%END%% > ./simcli.h
/*++++++++++++++
.IDENTIFICATION simcli.h
.LANGUAGE       C
.AUTHOR         Francois Ochsenbein, Marc Wenger [CDS]
.ENVIRONMENT    SIMBAD Client/Server
.KEYWORDS       
.VERSION  1.0   05-Jun-1993
.COMMENTS       Declaration of Functions for Simbad-Client
---------------*/
#ifndef SIMCLI_DEF
#define SIMCLI_DEF	0	/* To avoid recursive inclusions */

#ifndef _PARAMS
#ifdef __STDC__
#define _PARAMS(A)      A       /* ANSI */
#else
#define _PARAMS(A)      ()      /* Traditional */
#endif
#endif

#define MAX_USERID 16

int  simbad_connect   _PARAMS((char *node, char *serv, char *uname, char *pwd));
int  simbad_disconnect _PARAMS((int handle)) ;
int  simbad_query      _PARAMS((int handle, char *question, char *options)) ;
int  simbad_retrieve   _PARAMS((int handle, int number )) ;
int  simbad_findata    _PARAMS((int handle, char *astrotype, char *option )) ;
char *simbad_getdata   _PARAMS((int handle, int number )) ;
char *simbad_telldata  _PARAMS((int handle )) ;
char *simbad_error     _PARAMS((int handle )) ;

void cliopt            _PARAMS((int n,char **v,char *h,char *s,char *u,char *p)) ;
#endif /* SIMCLI_DEF */
%%END%%
echo ==== ./simclic.h
cat << %%END%% > ./simclic.h
/* client.h 04.03.93 */

#define OK 0
#define ERROR	-1
#define BAD_VERSION  -2
#define	NOEND	-5
#define UNABLEOPEN	-10	/* Unable to open the socket */
#define UIF_CONNEXIONERROR  -11
#define CONNEXIONERROR  -11

/* data types */
#define UIF_DATA 1
#define UIF_HELP 2
#define UIF_CLASS 3
#define UIF_PILE 4
#define UIF_MENU 5
#define UIF_ERROR 6
#define UIF_PROMPT 7
#define UIF_PROGRAM 8

#define UIF_LIST 9
/*
#define UIF_LIST 10
*/
#define UIF_EMPTYLIST 11
#define UIF_OTHERERROR 12

/* Receive types */
#define RCV_FILE      0      /* pas d'interpretation du nom distant */
#define RCV_FORMAT    1      /* interpretation de type format SIMBAD */

/* Messages associes aux erreurs de protocole cote client */
#define ERR_SOCKET	"Impossible to open the socket"
#define ERR_READ	"Impossible to read the socket"
#define ERR_WRITE	"Impossible to write on the socket"
#define ERR_OPEN_FILE 	"Impossible to open the file"
#define ERR_VERSION		"The client version is not accepted by the server"

/* Longueur des messages */
#define L_ERR_SOCKET 30
#define L_ERR_READ 30
#define L_ERR_WRITE 33
#define L_ERR_OPEN_FILE 28
#define L_ERR_VERSION  49

/* Structure utilisee pour transmettre le resultat des requetes */
typedef struct {
        int code;
	int length;
        char *msg;
}SimDatStruct;
%%END%%
echo ==== ./xorcrypt.h
cat << %%END%% > ./xorcrypt.h
#define XORKEY (unsigned char) 0xdd
#define EXCH(c) (((c & 0x0f)<<4) | ((unsigned char) (c & 0xf0)>>4))
#define XORC(c) (EXCH(c)^XORKEY)
char *XORD(s)
        unsigned char *s ;
{
        unsigned char *p, c;

        for (p=s; p && *p; p++)
        {
                c = *p^XORKEY;
                *p = EXCH(c);
        }

        return((char *) s);
}

#if 0
#define XORKEY 0x57
#define XORC(c) (c^XORKEY)
char *XORD(s)
	unsigned char *s ;
{
	unsigned char *p = s;
	while(*p) *p++ ^= XORKEY ;
	return((char *) s);
}
#endif

%%END%%
echo ==== ./clibib.c
cat << %%END%% > ./clibib.c
#include <stdio.h>
#include <string.h>
#include <simcli.h>

main(argc, argv) int argc; char **argv;
{
static char *cmdes[] = { 
	"hd 1",
	"hd 999999",
	"hd 2",
	"hd 3",
	"M31",
	"ads 7"
} ;
static char bibyears[80] = "1973/1994" ;

	char hostname[256], service[8],
		userid[MAX_USERID+1], passwd[MAX_USERID+1] ;
	int hh ;
	int i, icmd, nid, nref, lref ;
	char *p, *question;
	char buf[BUFSIZ];
	char obuf[BUFSIZ], option[BUFSIZ] ;
	char mainid[81] ;
	char *tab, *ptab, *etab ;
	char *typlist, *typ ;

	cliopt(argc,argv,hostname,service,userid,passwd) ;
	hh = simbad_connect(hostname,service,userid,passwd) ;
	if (hh < 0)
	{
		fprintf(stderr,"No connection done\\n") ;
		exit(1) ;
	}
	fprintf(stderr,"Connection done: Handle = %d\\n",hh) ;

	sprintf(option,"bibyears=%s",bibyears) ;
	simbad_query(hh,"",option) ;

	for (icmd=0 ; icmd < sizeof(cmdes)/sizeof(cmdes[0]) ; )
	{
		int nitems ; 
		*option = '\\0' ;
		printf("identifier [%s]: ", cmdes[icmd]);
		if (!gets(buf)) break;
		if (*buf) 
		{
			question = buf ;
		   printf("  bibyears [%s]: ", bibyears); gets(obuf);
			if (*obuf)
			{
				strcpy(bibyears,obuf) ;
				sprintf(option,"bibyears=%s",bibyears) ;
			}
		} 
		else question = cmdes[icmd++] ;
		nitems = simbad_query(hh,question,option) ;
		fprintf(stderr,"%s: # of objects found: %d\\n",question,nitems);
		if (nitems <= 0)
		{
			if (nitems < 0) fprintf(stderr,"Error: %s\\n",simbad_error(hh)) ;
			continue ;
		}

		/* loop on all objects */
		while (nitems--)
		{
		   int stat ;
		   char *astrotyplist, *typ ;

			/* retrieve one object */
		   stat = simbad_retrieve(hh,0) ;
		   fprintf(stderr,"stat(retrieve) = %d\\n",stat) ;
		   if (stat <= 0)
		   {
		   	fprintf(stderr,"retrieve error: stat=%d\\n", stat) ;
		   	break ;
		   }

			/* retrieve the main identifier */
			nid = simbad_findata(hh,"I.0","") ;
			if (nid == 1) 
			{
				strcpy(mainid,simbad_getdata(hh,0)) ;
				fprintf(stderr,"\\n*** id = %s, bibyears = %s\\n\\n",mainid,bibyears) ;
			}

			/* retrieve the bibliographical references and build a table */
			nref = simbad_findata(hh,"B","") ;
			if (nref == 0)
			{
				fprintf(stderr,"No references for %s\\n",mainid) ;
				continue ;
			}
			p = simbad_getdata(hh,0) ;
			lref = strlen(p)+1 ;
			ptab = tab = (char *) calloc(nref,lref) ;
			etab = tab + nref*lref ;
			strcpy(ptab,p) ;
			for (ptab += lref ; ptab < etab ; ptab += lref)
				strcpy(ptab,simbad_getdata(hh,0)) ;

#if 0
			/* display only codes */
			for (ptab = tab ; ptab < etab ; ptab += lref)
				fprintf(stderr,"%s\\n",ptab) ;
#endif

			/* display whole reference text */
			for (ptab = tab, i=0 ; ptab < etab ; ptab += lref)
			{
				fprintf(stderr,"=== %4d === %s\\n",++i,ptab) ;
				if (simbad_query(hh,ptab,"") != 1 || simbad_retrieve(hh,0) <= 0)
				{
					fprintf(stderr," No reference text found\\n") ;
					continue ;
				}
				typlist = simbad_telldata(hh) ;
				for (typ = strtok(typlist," ") ;
					  typ != NULL ;
					  typ = strtok(NULL," "))
				{
					char *reftxt ;
					simbad_findata(hh,typ,"") ;
					reftxt = simbad_getdata(hh,0) ;
					if (strcmp(typ,"R.R") == 0)
					{
						if (strcmp(ptab,reftxt) != 0)
						{
							fprintf(stderr," Other reference text found: %s\\n",
									  reftxt) ;
							break ;
						}
					}
					else fprintf(stderr,"%s\\n",reftxt) ;
				} 
			}
			free(tab) ;
		} /* end of loop on items in one query */
	} /* end of loop on commands */
	simbad_disconnect(hh) ;
}
%%END%%
echo ==== ./clicoord.c
cat << %%END%% > ./clicoord.c
#include <stdio.h>
#include <string.h>
#include <simcli.h>

main(argc,argv)
	int argc ; char **argv ;
{
	char hostname[256], service[8], 
		userid[MAX_USERID+1], passwd[MAX_USERID+1] ;
	char rec[256] ;
	int hh ;
	int nitems, ndata ;

	cliopt(argc,argv,hostname,service,userid,passwd) ;
	hh = simbad_connect(hostname,service,userid,passwd) ;
	if (hh < 0)
	{
		printf("Connection not done: %s.\\n",simbad_error(0)) ;
		exit(1) ;
	}
	printf("Connection done: Handle = %d\\n",hh) ;

	while(1)
	{
		printf("Give an identifier (CR to end): ") ;
		gets(rec) ;
		if (rec[0] == '\\0') break ;
		nitems = simbad_query(hh,rec,"") ;
		if (nitems >= 1)
		{
			simbad_retrieve(hh,1) ;  /* retrieve 1st object */
			ndata = simbad_findata(hh,"J","") ;
			if (ndata == 1)
				printf("Coord B2000 = %s\\n",
					simbad_getdata(hh,1)) ;
			else
				printf("No coordinates\\n") ;
		}
		else
			printf("Object not found.\\n") ;
	}
	simbad_disconnect(hh) ;
}
%%END%%
echo ==== ./clifct.c
cat << %%END%% > ./clifct.c
#include <stdio.h>
#include <string.h>
#include <simcli.h>

main(argc, argv) 
	int argc;
	char **argv;
{
	char hostname[256], service[8],
		 userid[MAX_USERID+1], passwd[MAX_USERID+1] ;
	int hh ;
	int ndata, nitem, num, ifound ;
	char fctbuf[BUFSIZ], reqbuf[BUFSIZ], optbuf[BUFSIZ] ;
	char *atypes, *cdata ;

	cliopt(argc,argv,hostname,service,userid,passwd) ;
	hh = simbad_connect(hostname,service,userid,passwd) ;
	if (hh < 0)
	{
		fprintf(stderr,"No connection done\\n") ;
		exit(1) ;
	}
	fprintf(stderr,"Main. Connection done: Handle = %d\\n",hh) ;

	while(1)
	{
		printf("\\nFunction: Q[uery],R[etrieve],T[elldata],F[indata],G[etdata],E[rror] : ") ;
		if (!gets(fctbuf)) break ;
		switch(tolower(*fctbuf))
		{
			case 'q':
			printf("request: ") ;
			if (!gets(reqbuf) || *reqbuf == '\\0') break ;
			printf("options: ") ;
			if (!gets(optbuf)) break ;
			nitem = simbad_query(hh,reqbuf,optbuf) ;
			printf("%d items found.\\n",nitem) ;
			break ;

			case 'r':
			printf("number: ") ;
			if (!gets(reqbuf)) break ;
			num = *reqbuf ? atoi(reqbuf) : 0 ;
			ifound = simbad_retrieve(hh,num) ;
			printf("object #%s retrieved. Remain: %d\\n",
				num == 0 ? "next" : reqbuf,ifound) ;
			break ;
			

			case 't':
			atypes = simbad_telldata(hh) ;
			printf("Data types found: %s\\n",atypes) ;
			break ;

			case 'f':
			printf("datatype: ") ;
			if (!gets(reqbuf)) break ;
			printf("options: ") ;
			if (!gets(optbuf)) break ;
			ndata = simbad_findata(hh,reqbuf,optbuf) ;
			printf("%d data found.\\n",ndata) ;
			break ;

			case 'g':
			printf("number: ") ;
			if (!gets(reqbuf)) break ;
			num = *reqbuf ? atoi(reqbuf) : 0 ;
			cdata = simbad_getdata(hh,num) ;
			printf("data #%s: %s\\n",num == 0 ? "next" : reqbuf,cdata) ;
			break ;

			case 'e':
			printf("Error code: %d\\n",simbad_errno(hh)) ;
			printf("Error message:\\n%s\\n",simbad_error(hh)) ;
			break ;

			default:
			printf("Unknown command: %s\\n",fctbuf) ;
			break ;
		}
	}
	simbad_disconnect(hh) ;
	printf("\\n") ;
}
%%END%%
echo ==== ./cliname.c
cat << %%END%% > ./cliname.c
#include <stdio.h>
#include <string.h>
#include <simcli.h>

int name_resolver() ;

main(argc,argv)
	int argc ; char **argv ;
{
static char *cmdes[] = { 
	"hd 1",
	"hd 999999",
	"ads 7",
	"name vega",
	"name sirius",
	"hd 8890"
} ;
	char hostname[256], service[8], userid[MAX_USERID+1], passwd[MAX_USERID+1] ;
	int hh ;
	int i, j, nbid ;
	char idlist[100][50] ;

	cliopt(argc,argv,hostname,service,userid,passwd) ;
	hh = simbad_connect(hostname,service,userid,passwd) ;
	if (hh < 0)
	{
		fprintf(stderr,"No connection possible.\\n") ;
		exit(1) ;
	}
	printf("Connection done: Handle = %d\\n",hh) ;

	for (i=0 ; i < sizeof(cmdes)/sizeof(cmdes[0]) ; i++)
	{
		nbid = name_resolver(hh,cmdes[i],idlist) ;
		printf("==== object: %s : %d identifiers:\\n",cmdes[i],nbid) ;
		for (j=0 ; j < nbid ; j++)
			printf("        %d: %s\\n",j,idlist[j]) ;
	}

	simbad_disconnect(hh) ;
}


int name_resolver(hh,cmde,idlist)
	int hh ;
	char *cmde ;
	char idlist[100][50] ;
{
	char str[256] ;
	int nitems, ndata ;
	int i, stat ;
	char *p ;

	strcpy(str,cmde) ;
	strcat(str,"!") ;

	nitems = simbad_query(hh,str,"") ;  /* query the object */
	if (nitems != 1) return(0) ;
	stat = simbad_retrieve(hh,0) ;      /* retrieve the object */
	ndata = simbad_findata(hh, "I", "");/* find the identifiers */
	for (i=0 ; i < ndata ; i++)
	{
		if ((p = simbad_getdata(hh,0)) != NULL)
			strcpy(idlist[i],p) ;
	}
	return(ndata) ;
}
%%END%%
echo ==== ./cliopt.c
cat << %%END%% > ./cliopt.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <simcli.h>

char *getpass();

void cliopt(n,v,h,s,u,p)
	int n ;
	char **v ;
	char *h, *s, *u, *p ;
{
	int ip = 1 ;
	char uu[MAX_USERID+4] ;

	*h = '\\0' ; *s = '\\0' ; *u = '\\0' ; *p = '\\0' ;

	if (n > 2 && isalpha(*v[ip]) && isdigit(*v[ip+1]))
	{
		strcpy(h,v[ip++]);
		n--;
	}

	if (n > 1 && isdigit(*v[ip]))
	{
		strcpy(s,v[ip++]) ;
		n-- ;
	}
	
	if (n > 1)
	{
		strcpy(u,v[ip++]) ;
		n-- ;
	}

	if (n > 1)
	{
		strcpy(p,v[ip++]) ;
		n-- ;
	}

	if (! *u)
	{
		fprintf(stderr,"simbad client userid: ") ;
		fgets(uu,MAX_USERID+2,stdin) ;
		uu[strlen(uu)-1] = '\\0' ;
		strcpy(u,uu) ;
	}
	if (! *p)
	{
		strcpy(p,getpass("simbad client passwd: ")) ;
	}
}
%%END%%
echo ==== ./clitest.c
cat << %%END%% > ./clitest.c
#include <stdio.h>
#include <string.h>
#include <simcli.h>

main(argc, argv) int argc; char **argv;
{
static char *cmdes[] = { 
	"hd 1",
	"hd 999999",
	"M31",
	"ads 7",
	"12 30 +45 34",
	"1987ApJ...315...28H",
} ;

	char hostname[256], service[8], 
		userid[MAX_USERID+1], passwd[MAX_USERID+1] ;
	int hh ;
	int i , k, ndata;
	char *p, *question;
	char buf[BUFSIZ];
	char obuf[BUFSIZ], *option;

	cliopt(argc,argv,hostname,service,userid,passwd) ;
printf("h=%s, s=%s, u=%s\\n",hostname,service,userid);
	hh = simbad_connect(hostname,service,userid,passwd) ;
	if (hh < 0)
	{
		char *text = simbad_error(hh) ;
		fprintf(stderr,"No connection done: %s\\n",text) ;
		exit(1) ;
	}
	fprintf(stderr,"Main. Connection done: Handle = %d\\n",hh) ;

	for (i=0 ; i < sizeof(cmdes)/sizeof(cmdes[0]) ; )
	{
		int nitems ; 
		printf("Your request [%s]: ", cmdes[i]);
		if (!gets(buf)) break;
		if (*buf) { question = buf, option = obuf;
		    printf("++Your option: "); gets(obuf);
		} 
		else question = cmdes[i++], option = "";
		nitems = simbad_query(hh,question,option) ;
		fprintf(stderr,"\\n====\\n") ;
		fprintf(stderr,
		      "Main. # of objects found ('%s'): %d\\n",question,nitems);
		fprintf(stderr,"====\\n");
		if (nitems <= 0)
		{
			if (nitems < 0)
				fprintf(stderr,"Error: %s\\n",simbad_error(hh)) ;
			continue ;
		}
		while (nitems--)
		{
		    int stat ;
		    char *astrotyplist, *typ ;

		    stat = simbad_retrieve(hh,0) ;
		    fprintf(stderr,"stat(retrieve) = %d\\n",stat) ;
		    if (stat <= 0)
		    {
		    	fprintf(stderr,"retrieve error: stat=%d\\n",
		    		stat) ;
		    	break ;
		    }
		    fprintf(stderr,"===== Available astrotypes: %s\\n", 
			astrotyplist = simbad_telldata(hh));
		    for (typ = strtok(astrotyplist," ") ;
			 typ != NULL ;
			 typ = strtok(NULL," "))
		    {
			ndata = simbad_findata(hh,typ,"") ;
			fprintf(stderr,"===== %d data of astrotype %s:\\n",
				ndata,typ) ;
			while (p = simbad_getdata(hh,0))
				fprintf(stderr,"    %s\\n", p);
		    }
		}
	}
	simbad_disconnect(hh) ;
}

%%END%%
echo ==== ./clitime.c
cat << %%END%% > ./clitime.c
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <simcli.h>

#define CURRTIME time((time_t *) NULL)

main(argc,argv)
	int argc ; char **argv ;
{
static char *cmdes[] = { 
	"hd 1",
	"hd 2",
	"hd 3",
	"hd 4",
	"hd 5"
} ;
	char hostname[256], service[8], 
		userid[MAX_USERID+1], passwd[MAX_USERID+1] ;
	int hh ;
	int t,i ;
	time_t time0 ;

	cliopt(argc,argv,hostname,service,userid,passwd) ;

	time0 = CURRTIME ;
	hh = simbad_connect(hostname,service,userid,passwd) ;

	if (hh < 0)
	{
		fprintf(stderr,"No connection done.\\n") ;
		exit(1) ;
	}
	fprintf(stderr,"Main. Connection done: Handle = %d. time: %d sec.\\n",
			         hh,CURRTIME-time0) ;

	time0 = CURRTIME ;
	for (t=0 ; t < 100 ; t++)
	{
		for (i=0 ; i < sizeof(cmdes)/sizeof(cmdes[0]) ; i++)
		{
			int nitems ;
			nitems = simbad_query(hh,cmdes[i],"") ;
			fprintf(stderr,".") ;

			if (nitems <= 0) continue ;
			while (nitems--)
			{
				int stat ;
				stat = simbad_retrieve(hh,0) ;
			}
		}
		if (t > 0 && (t+1)%10 == 0)
			fprintf(stderr," %5d objects received.\\n",
				(t+1)*sizeof(cmdes)/sizeof(cmdes[0])) ;
	}

	time0 = CURRTIME - time0 ;
	fprintf(stderr," %5d objects received. Time: %d sec (%6.2f sec/obj)\\n",
		t*sizeof(cmdes)/sizeof(cmdes[0]), time0,
		(double) time0 / ((double) t*sizeof(cmdes)/sizeof(cmdes[0]))) ;

	simbad_disconnect(hh) ;
}
%%END%%
echo ==== ./skclient.c
cat << %%END%% > ./skclient.c
/*++++++++++++++
.IDENTIFICATION skclient.c
.LANGUAGE       C
.AUTHOR         Francois Ochsenbein [CDS]
.ENVIRONMENT    Internet
.KEYWORDS       Client/Server
.VERSION  1.0   04-Aug-1992
.VERSION  1.1   20-Aug-1992: Added sk_obeyserver
.VERSION  1.2   21-Oct-1992: Added sk_fromclient. sk_obeyserver now requires
			functions.
.VERSION  2.0   10-May-1993: 
.VERSION  2.1   02-Jul-1993: Added sk_error, sk_setlog
.VERSION  2.2   03-Mar-1994: ! marks root
.VERSION  2.3   08-Jul-1994: sk_connect returns -2 when connection refused
			by peer.
.VERSION  2.4   03-Nov-1994: Bufferization
.VERSION  2.5   16-Jan-1995: BASIC option; sk_setlog put in skio.c
.COMMENTS       Client routines
---------------*/

#ifndef NSOCKS
#define NSOCKS 64
#endif
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <stdlib.h>
#include <netdb.h>
#ifdef VMS	/* All definition files in single directory */
#include <types.h>
#include <socket.h>
#include <in.h>
#else		/* Assume standard Unix */
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>	/* Internet sockets definitions	*/
#endif
#define mexp(b, l)	(b ? realloc(b,l) : malloc(l))	/* Reallocation */

typedef struct {
     char interrupt;	/* Interrupt Signal */
     char unused[3];
     char *server;	/* Server Information: Host/Service:pid.plug */
} PLUG;
typedef struct {		/* Buffer */
     int abytes, ubytes;	/* Allocated, Used */
     char *buffer;
} ABUF;

extern char *getlogin();
extern char *sys_errlist[];
extern FILE *sk_getlog();

static PLUG plugs[NSOCKS];
static ABUF errs;		/* Error message */
static char in_open;		/* Set to 1 if in sk_open */

/*============================================================================
 *		Error routines
 *============================================================================*/
static int cat_err(msg)
/*++++++++++++++++
.PURPOSE  Append error to error buffer
.RETURNS  Length of full message
-----------------*/
  char *msg;	/* IN: Message to append	*/
{
  int len;
    len = errs.ubytes + strlen(msg);
    if (len >= errs.abytes) {		/* Have to expand error buffer */
    	errs.abytes = (len + 1 + 63)&~63;
    	errs.buffer = mexp(errs.buffer, errs.abytes);
    }
    strcpy(errs.buffer + errs.ubytes, msg);
    errs.ubytes = len;
    return(errs.ubytes);
}

static void err2(msg, text)
/*++++++++++++++++
.PURPOSE  Write msg: text to log file
.RETURNS  ---
-----------------*/
  char *msg;	/* IN: Message to append	*/
  char *text;	/* IN: Second message		*/
{
  FILE *logfile;

    if (logfile = sk_getlog()) {
    	errs.ubytes = 0;			/* Free error message */
    	cat_err(msg);
    	if (text) cat_err(": "), cat_err(text);
    	fprintf(logfile, "%s\\n", errs.buffer), fflush(logfile);
    }
}

static void put_err(msg)
/*++++++++++++++++
.PURPOSE  Write msg: error message
.RETURNS  ---
-----------------*/
  char *msg;	/* IN: Message to append	*/
{   
    err2(msg, sys_errlist[errno]); 
}

/*============================================================================
 *		Internal routines
 *============================================================================*/
static int set_slot(plug, val)
/*++++++++++++++++
.PURPOSE  Set the plug slot to a value
.RETURNS  Previous value of the slot
-----------------*/
  int plug;	/* IN: Started Socket Number 	*/
  int val;	/* IN: Value to set to slot	*/
{
  int ret;
    if (plug < 0) return(-1);
    if (plug >= NSOCKS) return(-1);
    ret = plugs[plug].interrupt;
    plugs[plug].interrupt = val;
    return(ret);
}

/*============================================================================
 *		Public routines
 *============================================================================*/
char *sk_error()
/*++++++++++++++++
.PURPOSE  Get the last error message
.RETURNS  The error message
-----------------*/
{
    return(errs.buffer);
}

int sk_kill(plug, sig)
/*++++++++++++++++
.PURPOSE  Interrupt the exchange with Server
.RETURNS  Number of bytes transmitted (1) / Error
-----------------*/
  int plug;		/* IN: Started Socket Number 	*/
  int sig;		/* IN: Signal to send to Server */
{
  static char bsig[2];
  int stat;

    bsig[0] = sig ? sig : SIGINT;
#ifdef DEBUG
    fprintf(stderr, "send(%d, ^%c, 1, %d)\\n", plug, bsig[0]|0100, MSG_OOB);
#endif
    stat = send(plug, bsig, 1, MSG_OOB);
    if (stat < 0) put_err("Send OOB");
    return(stat);
}

/*============================================================================*/

int sk_obeyserver(plug, digest, more)
/*++++++++++++++++
.PURPOSE  Dialog with the server using two routines, 
	. digest which gets what comes from the Server, and
	. more which is called when the Server requires more data.
	These functions have two parameters (buffer, length), 
	    and return a number of bytes processed.
	The following conventions are used:
	^D = End of transfer from Server (return from this function)
	^B = Start of Buffer Mode (server will send length + data)
	^C = Error Message as a Buffer 
	^F = Server asks to send a Buffer (length + data)
	     In this case, data acquired from more file are sent to Server.
.RETURNS  Number of bytes transferred / -1=Error 
-----------------*/
  int plug;		/* IN: Started Socket Number 	*/
  int (*digest)();	/* IN: Routine getting what's sent by Server */
  int (*more)();	/* IN: Routine generating data    for Server */
{

  char bufop, eof, c;
  int lb, stat, bytes, i;
  char *b, *p, buf[BUFSIZ];

  	/* WRITE a file, i.e. READ the socket.
	   The Server may send in BUFFERED mode indicated by ^B
	*/

    bytes = stat = lb = 0; b = (char *)0;
    set_slot(plug, 0);				/* Clear Interrupt */
    for (eof=bufop=0; !eof; ) {
	if (bufop) {    /* Get in BUFFER mode */
	    stat = sk_getl(plug);    /* Size  */
#ifdef DEBUG
	    fprintf(stderr, "\\nHave to read %d bytes\\n", stat);
#endif
	    if (stat < 0) break;
	    if (stat == 0) { bufop = 0; continue; }
	    if (lb < stat) { lb = (stat+1023)&(~1023); b = mexp(b, lb); }
	    if (sk_get(plug, b, stat) != stat) { stat = -1; break; }
	    if (bufop == 2) {				/* Error msg */
	    	if (stat < lb) b[stat] = 0;
	    	err2(b, (char *)0);
	    	bufop = 0;		/* Error is a single buffer  */
	    	continue;
	    }
	    p = b;
	} else {
	    stat = sk_read( plug, buf, sizeof buf );
	    if (stat < 0) { stat = -1; break; }
	    if (stat == 0) {
	    	if (!in_open) 
	    	    err2("++++Server closed connection", (char *)0);
		stat = -1;
		break;
	    }
		/* More than what's required may have been read. 
		   Therefore locate first control char with octal \\00x
		   which has a meaning in the protocol
		*/
	    for (i=0; (i<stat) && (buf[i]&(~7)); i++) ;
	    if (i < stat) {	/* Special char located. 
				   Put back what's over-read. */
		if (++i < stat) sk_iosave(plug, buf+i, stat-i);
		stat = i;
	    }
	    switch(c = buf[stat-1]) {
	      case '\\04': eof = 1; --stat; break;
	      case '\\06': /* TRANSMIT data from more in Buffer Mode */
		if (--stat) (*digest)(buf, stat);
		if (!b) { lb = 60*1024; b = malloc(lb); }
	    	stat = (*more)(b, lb); 
	    	if (stat < 0) { eof = 1; continue; }	/* Will stop */
	    	if (sk_putl(plug, stat) < 0) {
		    stat = -1; 
		    eof = 1; 				/* Will stop */
		}
	    	if (stat <= 0) continue; 
	    	if (sk_write(plug, b, stat) != stat) {
		    stat = -1; 
		    eof = 1; 				/* Will stop */
		}
		continue;
	      case '\\03': 		 		/* Error msg */
	      case '\\02': bufop = c-1; --stat; 
		sk_write(plug, "\\06", 1);		/* Send Ack  */
		break;
	    }
	    p = buf;
	}
	if ((*digest)(p, stat) < 0) { 
		stat = -1; 
		break; 
	}
	if (stat > 0) bytes += stat;
    }

    if (b) free(b);
    return(stat < 0 ? stat : bytes);
}

static int fdigest = 1;		/* File number from sk_fromserver */
static int fmore   = 0;		/* File number from sk_fromserver */

static int mydigest(buf, len)
/*++++++++++++++++
.PURPOSE  Function to write to fdigest
.RETURNS  Number of bytes written
-----------------*/
  char *buf;	/* IN: Buffer to write   */
  int  len;	/* IN: Bytes written out */
{
  int n;

    n = write(fdigest, buf, len);
    if (n < 0) put_err("****sk_fromserver Writing File");
    return(n);
}

static int mymore(buf, len)
/*++++++++++++++++
.PURPOSE  Function to write to fmore
.RETURNS  Number of bytes written
-----------------*/
  char *buf;	/* IN: Buffer to write   */
  int  len;	/* IN: Bytes written out */
{
  int n;

    n = read(fmore, buf, len);
    if (n < 0) put_err("****sk_fromserver Reading File");
    return(n);
}

int sk_fromserver(plug, fh, fsend)
/*++++++++++++++++
.PURPOSE  Copy what comes from server to fh file. This function obey to
	the following conventions:
	^D = End of transfer from Server (return from this function)
	^B = Start of Buffer Mode (server will send length + data)
	^F = Server asks to send a Buffer (length + data)
	     In this case, data from fsend file are sent to Server.
.RETURNS  Number of bytes transferred / -1=Error 
-----------------*/
  int plug;	/* IN: Started Socket Number 	*/
  int fh;		/* IN: OUTput file handle	*/
  int fsend;	/* IN: INput file to send if Server asks to */
{
    fdigest = fh; fmore = fsend;
    return(sk_obeyserver(plug, mydigest, mymore));
}

/*===========================================================================*
		Connection to Server
 *===========================================================================*/
static char *user;	/* Set by sk_connect */
static char *pswd;	/* Set by sk_connect */

static int open_digest(buf, len)
/*++++++++++++++++
.PURPOSE  At Open, writes what comes from Server
.RETURNS  0 = OK
.REMARKS  At this connection level, what comes is just written on stderr.
-----------------*/
  char *buf;	/* IN: Buffer to write   */
  int  len;	/* IN: Bytes written out */
{
    if (len <= 0) return(len);
    buf[len] = 0;
#ifdef DEBUG
	printf("++++open_digest, received <%s>\\n", buf);
#endif
    err2(buf, (char *)0);
    return(len);
}

static int open_more(buf, len)
/*++++++++++++++++
.PURPOSE  At Open (Connect), write the Password
.RETURNS  Number of bytes 
-----------------*/
  char *buf;	/* IN: Buffer to write   */
  int  len;	/* IN: Size of  buf	 */
{
  int n;
#ifdef DEBUG
	printf("++++open_more called\\n");
#endif
    n = pswd ? strlen(pswd) : 0;
    if (n) strcpy (buf, pswd), pswd = (char *)0;
    return(n);
}

int sk_open(machine, service)
/*++++++++++++++++
.PURPOSE  Start a client connecting to a machine / Service
.RETURNS  File number; -1 when can't connect, -2 when connection refused
.REMARKS  Machine and Service can be symbolic (letters) or numeric
	Non-numeric services are to be found in /etc/services.
	At the prompt (\\n-terminated) sent by the Server, the client
	replies with User@Machine
-----------------*/
  char *machine;	/* IN: Machine to connect to */
  char *service;	/* IN: Service to connect to */
{
  int plug;			     	/* socket to "plug" into the socket */
  struct sockaddr_in socketname; 	/* mode, addr, and port for socket */
  struct hostent *remote_host;		/* internet numbers, names   */
  struct servent *ps;			/* Returned by getservbyname */
  char buf[120];
  int  len, stat;
  char *p, *pu;

    sk_errfct(put_err);			/* Save & Print error messages */
    /* make an internet-transmitted, file-i/o-style, protocol-whatever plug */
    if ( (plug = socket( AF_INET, SOCK_STREAM, 0 )) < 0 ) {
	put_err("****sk_open: can't start socket");
	return(-1);
    }
    if (plug >= NSOCKS) {
        sprintf(buf, "%d", plug);
	err2("****(Client)Too many opened sockets", buf);
	return (-1);
    }
    if (plugs[plug].server) free(plugs[plug].server);
#ifdef NODELAY
	stat = TCP_NODELAY;
	if (setsockopt(plug, IPPROTO_TCP, TCP_NODELAY,
	    (char *)&stat,sizeof(stat))<0){
	    put_err("Can't setsockopt(TCP_NODELAY)");
	    return(-1);
	}
#endif

	/* Fill in the socket structure with Host and Service */
    socketname.sin_family = AF_INET;
    if (isalpha(*machine)) {
    	if ( ! (remote_host = gethostbyname(machine)))  {
    	    err2("****sk_open: unknown host", machine);
	    return(-1);
	}
    	(void) memcpy( 
		(char *)&socketname.sin_addr, 
		(char *)remote_host->h_addr, 
		remote_host->h_length );
    }
    else socketname.sin_addr.s_addr = inet_addr(machine);
    if (isalpha(*service)) {
	ps = getservbyname(service, (char *)0);
	if (!ps)  {
	    err2("****sk_open: unknown service", service);
	    return(-1);
	}
    	socketname.sin_port = ps->s_port;
    }
    else socketname.sin_port = htons(atoi(service));

    	/* plug into the listening socket */
    if ( connect( plug, (struct sockaddr *) &socketname,
		  sizeof(socketname)) < 0 ) {
	put_err("****sk_open: can't connect");
	return(-1);
    }

    	/* Server sends an Identification line (host/service:pid.plug);
    	   keep it in the PLUG */
    len = sk_gets(plug, buf, sizeof(buf)); 
    if (len <= 0)  return(-1);
    buf[len-1] = 0;			/* Remove \\n */
    plugs[plug].server = malloc(len);
    strcpy(plugs[plug].server, buf);
	
	/* Define local username */
    pu = getenv("USER");
    if (!pu) pu = getlogin(); 
    if (!pu) pu = "daemon";
    
    	/* Send Username + Machine */
    strcpy(buf, pu); p = buf + strlen(buf);
    if (!getuid()) *(p++) = '!';	/* Indicates root privilege */
    *(p++) = '@';
    /* printf("... gethostbyname with %d bytes\\n", sizeof(buf)-i); */
    gethostname(p, (buf+sizeof(buf))-p); p += strlen(p);
    if (user) *(p++) = ':', strcpy(p, user);
    sk_puts(plug, buf);
    /* printf("sk_put(%s)\\n", buf); */

	/* Wait for OK from Server (normally ^D).
	   The Server may ask for a Password (^F),
	   passed through standard communications */
    in_open = 1;
    if (sk_obeyserver(plug, open_digest, open_more) < 0) {
    	close(plug);
    	return(-2);
    }
    in_open = 0;
    return(plug);
}

int sk_connect(machine, service, username, password)
/*++++++++++++++++
.PURPOSE  Start a client connecting to a machine / Service,
		and send User/Password
.RETURNS  Plug number ; -1 when can't connect, -2 when connection refused
.REMARKS  Upon successful identification, Server sends ^D;
	it sends otherwise an error message which is reproduced
	on stderr.
-----------------*/
  char *machine;	/* IN: Machine to connect to */
  char *service;	/* IN: Service to connect to */
  char *username;	/* IN: A username for Server */
  char *password;	/* IN: A password for Server */
{
  int plug;		/* socket to "plug" into the socket */

    user = username; pswd = password;
    plug = sk_open(machine, service);
    user = pswd = (char *)0;

    return(plug);
}
%%END%%
echo ==== ./skio.c
cat << %%END%% > ./skio.c
/*++++++++++++++
.IDENTIFICATION skio.c
.LANGUAGE       C
.AUTHOR         Francois Ochsenbein [CDS]
.ENVIRONMENT    
.KEYWORDS       
.VERSION  1.0   04-Aug-1992
.VERSION  1.1   20-Aug-1992: Added sk_getl, sk_putl
.VERSION  1.2   12-Dec-1992: Added sk_setb
.VERSION  2.0   10-May-1993:
.VERSION  2.1   03-Nov-1994: Added sk_iolog
.VERSION  2.2   16-Jan-1995: BASIC option; added sk_setlog
.COMMENTS       Read/Write on Sockets
---------------*/

#ifndef NSOCKS
#define NSOCKS 64
#endif

#include <stdio.h>

#ifdef VMS			/* Special definitions for VAXes (as always) */
#include <types.h>
#include <in.h>
static FILE *logfile = (FILE *)(-1);	/* VAX can't assign stderr !! */
#else
#include <sys/types.h>  /* ntohl */
#include <netinet/in.h> /* Byte order */
static FILE *logfile = stderr;  	/* Log-file for errors	*/
#endif

typedef void (*FCT)();
typedef struct {	/* A buffer to save what's read */
    int size, offset;	/* Size of buf, position in buf */
    char *buf;		/* Buffer 			*/
} BUF;
extern void perror();

static BUF *inputs[NSOCKS]; 
static FCT errfct = perror;	/* Function used to report errors */
static int sksize = 0;		/* Individual size of sockets */

#include <string.h>	/* For memcpy */
#include <stdlib.h>	/* For malloc */

static FILE *iologfile;		/* Debugging Log-file (set by sk_iolog) */

static void logb(fct, buf, len)
/*++++++++++++++++
.PURPOSE  Log what's comes in
.RETURNS  ---
-----------------*/
  char *fct, *buf; int len;
{ 
  int i; char c;
    if (!iologfile) return;
    fprintf(iologfile, "....%8s:%5d bytes \\"", fct, len);
    for (i=0; i<len; i++){
	if (i == 24) {		/* Skip remaining */
	    fprintf(iologfile, "\\"...");
	    i = len-1;
	}
	switch (c=buf[i]){
	case '\\\\': fprintf(iologfile, "\\\\\\\\"); continue;
	case '"':  fprintf(iologfile, "\\\\\\""); continue;
	case '\\n': fprintf(iologfile, "\\\\n"); continue;
	case '\\r': fprintf(iologfile, "\\\\r"); continue;
	case '\\t': fprintf(iologfile, "\\\\t"); continue;
	default: 
	    if (isprint(c)) fputc(c, iologfile);
	    else fprintf(iologfile, "\\\\%03o", c & 0xff);
	    continue;
	}
    }
    if (i <= 24) fputc('\\"', iologfile);
    fputc('\\n', iologfile);
    fflush(iologfile);
    return;
}

static void logl(fct, val)
/*++++++++++++++++
.PURPOSE  Log what's comes in
.RETURNS  0
-----------------*/
  char *fct; int val;
{ 
    if (!iologfile) return;
    fprintf(iologfile, "....%8s= %d\\n", fct, val);
    fflush(iologfile);
    return;
}

static int err3(ssp, plug, len)
/*++++++++++++++++
.PURPOSE  Error report
.RETURNS  0
-----------------*/
  char *ssp;	/* IN: Subroutine name */
  int  plug;	/* IN: Socket number */
  int len;	/* IN: Length variable */
{
  char buffer[128];
    sprintf(buffer, "****%s plug#%d for %d bytes", ssp, plug, len);
    (*errfct)(buffer);
    return(0);
}

static int bread(fno, buf, len)
/*++++++++++++++++
.PURPOSE  Internal read from associated buffer
.RETURNS  Length of what's read
-----------------*/
  int fno;	/* IN: File Descriptor */
  char *buf;	/* OUT: Buffer filled  */
  int  len;	/* IN: Max len to read */
{ 
  int bytes; BUF *b;
    b = inputs[fno]; if (!b) return(0);
    bytes = (b->offset + len) > b->size ? b->size - b->offset : len;
    memcpy(buf, b->buf+b->offset, bytes); b->offset += bytes;
    if (b->offset >= b->size) free(b), inputs[fno] = (BUF *)0;
    if (iologfile) logb("sk_read(from saved buffer)", buf, bytes);
    return(bytes);
}

int sk_setb(block)
/*++++++++++++++++
.PURPOSE  Set the size of blocks for socket transfer
.RETURNS  The previous value of the socket size
.REMARKS  A value < 1 does not change the socket blocksize.
-----------------*/
  int block;	/* IN: Size of socket blocks in bytes (< 511) of blocks */
{
  int ob;
    ob = sksize; 
    if (block > 0) {
	sksize = block;
	if (sksize < 511) sksize *= 512;
    }
    return(ob);
}

FCT sk_errfct(f)
/*++++++++++++++++
.PURPOSE  Set the error function
.RETURNS  The previous errfct function
.REMARKS  Default is perror.
-----------------*/
  FCT f;	/* IN: New errfct function */
{
  FCT o;
    o = errfct;
    errfct = f ? f : perror;
    return(o);
}

FILE *sk_getlog()
/*++++++++++++++++
.PURPOSE  Retrieve the current LogFile
.RETURNS  The current logfile
-----------------*/
{
#ifdef VMS
    return(logfile == (FILE *)(-1) ? stderr : logfile);
#else
    return(logfile);
#endif
}

FILE *sk_setlog(f)
/*++++++++++++++++
.PURPOSE  Set the logfile (where to write errors)
.RETURNS  The previous DEBUG logfile
.REMARKS  Default is no debugging log
-----------------*/
  FILE *f;	/* IN: New log file	*/
{
  FILE *o;
#ifdef VMS
    o = logfile == (FILE *)(-1) ? stderr : logfile;
#else
    o = logfile;
#endif
    logfile = f;
    return(o);
}

FILE *sk_iolog(f)
/*++++++++++++++++
.PURPOSE  Set the DEBUG logfile
.RETURNS  The previous DEBUG logfile
.REMARKS  Default is no debugging log
-----------------*/
  FILE *f;	/* IN: New log file; value -1 to get only current */
{
  FILE *o;
    o = iologfile;
    if (f != (FILE *)(-1)) iologfile = f;
    return(o);
}

int sk_iosave(fno, buf, len)
/*++++++++++++++++
.PURPOSE  Save in a buffer the provided data
.RETURNS  Number of bytes in buffer associated to fno
.REMARKS  Can't save in existing buffer
-----------------*/
  int fno;	/* IN: File Descriptor 	*/
  char *buf;	/* IN: Data to save    	*/
  int  len;	/* IN: Length of data 	*/
{
  BUF *b; 
    if (len <= 0) return(0);
    if (fno >= NSOCKS) {
	err3("sk_iosave", fno, len);
	return(-1);
    }
    if (iologfile) logb("sk_iosave", buf, len);
    if (b = inputs[fno]) {	/* Buffer already exists.	*/
	if (b->offset < len) err3(
	    "sk_iosave/existing buffer with too small offset", fno, len);
	else b->offset -= len, memcpy(b->buf+ b->offset, buf, len);
    }
    else {			/* New buffer			*/
	inputs[fno] = b = (BUF *)malloc(len + sizeof(BUF));
	b->offset = 0; b->size = len;
	b->buf = (char *)(b+1);
	memcpy(b->buf,  buf, len);
    }
    return (b->size - b->offset);
}

int sk_read(fno, buf, len)
/*++++++++++++++++
.PURPOSE  Read up to a specified number of bytes on a socket.
.RETURNS  Number of bytes read
.REMARKS  No attempt to fill the buffer.
-----------------*/
  int fno;	/* IN: File Descriptor */
  char *buf;	/* OUT: Buffer filled  */
  int  len;	/* IN: Max len to read */
{
  int i;
    if (inputs[fno]) i = bread(fno, buf, len);
    else i = read(fno, buf, len);
    if (i < 0) err3("sk_read", fno, len); 
    if (iologfile) logb("sk_read", buf, i);
    return(i);
}

int sk_get(fno, buf, len)
/*++++++++++++++++
.PURPOSE  Read the specified number of bytes on a socket.
.RETURNS  Number of bytes read. Is normally equal to len.
-----------------*/
  int fno;	/* IN: File Descriptor */
  char *buf;	/* OUT: Buffer filled  */
  int  len;	/* IN: Max len to read */
{
  char *p, *pe;
  int i;

    for (p = buf, pe = p+len; p < pe; p += i) {
  	if (inputs[fno]) i = bread(fno, p, pe-p);
  	else i = read(fno, p, pe-p);
  	if (i < 0) err3("sk_get", fno, len); 
	if (i <= 0) break;
    }
    if(iologfile) logb("sk_get", buf, p-buf);
    return (p - buf);
}

int sk_gets(fno, buf, len)
/*++++++++++++++++
.PURPOSE  Read a line (terminated by a newline) on a socket
.RETURNS  Number of bytes read, including the \\n. 
.REMARKS  No NUL character appended.
-----------------*/
  int fno;	/* IN: File Descriptor */
  char *buf;	/* OUT: Buffer filled  */
  int  len;	/* IN: Max len to read */
{
  char *p, *n, *pe;
  int i;

    for (p = n = buf, pe = p+len; p < pe; ) {
  	if (inputs[fno]) i = bread(fno, p, pe-p);
  	else i = read(fno, p, pe-p);
	if (i < 0) err3("sk_gets", fno, len);
	if (i <= 0) break;	/* End of File */
	for (n=p+i; (p<n) && (*p!='\\n'); p++) ;
	if ((p<n) && (*p=='\\n')) { p++; break; }
    }
    if (p < n) sk_iosave(fno, p, n-p);		/* I read too much ... */
    if(iologfile) logb("sk_gets", buf, p-buf);
    return (p - buf);
}

int sk_getl(fno)
/*++++++++++++++++
.PURPOSE  Read a 32-bit integer on a socket
.RETURNS  What's read; -1 when error
-----------------*/
  int fno;        /* IN: opened socket */
{
  int stat;
    if (sk_get(fno, &stat, sizeof(stat)) < 0) return(-1);
    if (iologfile) logl("sk_getl", ntohl(stat));
    return(ntohl(stat));
}

/*============================================================================*/

int sk_write(fno, buf, len)
/*++++++++++++++++
.PURPOSE  Write a specified number of bytes on a socket.
.RETURNS  Number of bytes written, normally identical to len
.REMARKS  Several trials if necessary
-----------------*/
 int fno;	/* IN: File Descriptor */
 char *buf;	/* IN: Buffer to send  */
 int  len;	/* IN: Max len to read */
{
 char *p, *pe;
 int i, b;

    for (p = buf, pe = p + len; p < pe; p += i) {
	b = pe-p;
	if (sksize && (b > sksize)) b = sksize;
	i = write(fno, p, b);
	if (i <= 0) { 
		if (i < 0) err3("sk_write", fno, len);
		break;
	}
    }
    if (iologfile) logb("sk_write", buf, p-buf);
    return (p - buf);
}

int sk_put(fno, buf)
/*++++++++++++++++
.PURPOSE  Write a text terminated by a NUL character
.RETURNS  Number of bytes written
.REMARKS  Several trials if necessary
-----------------*/
  int fno;	/* IN: File Descriptor */
  char *buf;	/* IN: Buffer to send  */
{
    return(sk_write(fno, buf, strlen(buf)));
}

int sk_puts(fno, buf)
/*++++++++++++++++
.PURPOSE  Write a line (followed by a \\n)
.RETURNS  Number of bytes written
.REMARKS  Several trials if necessary
-----------------*/
  int fno;	/* IN: File Descriptor */
  char *buf;	/* IN: Buffer to send  */
{
  char *p;
  int i;

    p = buf + strlen(buf); *p = '\\n';
    i = sk_write(fno, buf, 1 + (p-buf));
    *p = 0;
    return (i);
}

int sk_putl(fno, val)
/*++++++++++++++++
.PURPOSE  Write a 32-bit integer on a socket
.RETURNS  Number of bytes written
-----------------*/
  int fno;        /* IN: opened socket */
  int val;	/* IN: Value to write */
{
  int nval;
  int  stat;

    if (iologfile) logl("sk_putl", val);
    nval = htonl(val);
    stat = sk_write(fno, &nval, sizeof(nval));
    return (stat != 4 ? -1 : stat);
}

int sk_close(fno)
/*++++++++++++++++
.PURPOSE  Close the opened socket
.RETURNS  -1 = error
-----------------*/
  int fno;        /* IN: socket to close */
{
  int  stat;
    stat = close(fno);
    if (stat < 0) err3("sk_close", fno, 0);
    if (iologfile) logl("sk_close", fno);
    return (stat);
}
%%END%%
echo ==== ./simcli.c
cat << %%END%% > ./simcli.c
/*+++++++++++++++
.IDENTIFICATION smbcli.c
.LANGUAGE       C
.AUTHOR         Francois Ochsenbein, Marc Wenger [CDS]
.ENVIRONMENT    
.KEYWORDS       
.VERSION  1.0   25-May-1993 Creation
.VERSION  1.1   05-Jun-1993: simbad_telldata
.VERSION  1.2   16-Jun-1993 (Pacific Time !!!): #define OK 1
                             suppress sk_routines error messages
.VERSION  1.2   16-Jun-1993 (European Time !!): Buffered results.
.VERSION  1.3   07-Dec-1993 Macro for setting specific formats on server side
.VERSION  1.4   08-Feb-1994 Use only UIF_LIST code
.VERSION  1.5   01-Mar-1994 Set an application name
.VERSION  1.6   05-May-1994: Take care of EMPTYLIST
.VERSION  1.7   07-Oct-1994  simbad_disconnect: check .answer == NULL before
                             KillData (Fix proposed by Song Yom/HEASARC on
                             7 Apr 94. - yom@astd3.gsfc.nasa.gov)
.VERSION  1.8   25-Nov-1994  Problem with empty result: no bye !!!
.VERSION  1.9   17-Jan-1994  Modification of REF_INTRO define
.VERSION  1.91  20-Jun-1995  into ANSI
.COMMENTS       
---------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <simclic.h>
#include <simcli.h>

#ifndef _PARAMS
#ifdef __STDC__
#define _PARAMS(A)      A       /* ANSI */
#define _TYPE(A)	A
#define _DCL		0
#else
#define _PARAMS(A)      ()      /* Traditional */
#define _TYPE(A)
#define _DCL		1
#endif
#endif

#define DEFAULT_NODE         "130.79.128.4"
#define DEFAULT_SERVICE      "1674"
#define MAX_HANDLES    10

#define DATABUF	  4096		/* Default & Increment for buf */
#define DATATYPE    32		/* Number of different data types */
#define DATALINE   256		/* Default Number of lines	*/
#define MAXITYPE    14		/* Maximal allowed length of a datatype */

extern char *sk_error  _PARAMS((void));

#define EOS    '\\0'
#define YES    1
#undef  OK
#define OK     1
#define NO     0
#define NOK    0

typedef struct {	/* Data kept as result from Simbad Query */
    int  handle;		/* Related Handle number   */
    int  abuf, ubuf, obuf ; 	/* Allocated, Used, Offset */
    char *buf;			/* Data buffer */
    int  aline, uline, oline; 
    int  *line;			/* Array to beginning of lines */
    int  atype, utype, otype;
    int  *type;			/* Array of lines starting with data element */
    int  atell;			/*	Allocated bytes for .. */
    char *tell;			/* Space-separated list of existing datatypes */
    char dtype[MAXITYPE+2];	/* Asked datatype; room for ending blank \\0 */
    int  aquery;
    char *query;		/* Query to send if data asked for */
  } SMB_DATA;

typedef struct {
	int  sock ;                 /* Socket number for the connection */
	char *question ;
	SMB_DATA *answer;
	char *errormsg ;
	int answertype ;
	int status ;
	int nbobj ;
	int objnum ;
    } SMB_HANDLE ;

#define isopen(h) (h >= 0 && h < MAX_HANDLES && smb_handle[h].status != H_FREE)
#define existdata(h) (smb_handle[hand].status == H_LIST || \\
                      smb_handle[hand].status == H_OBJECT || \\
                      smb_handle[hand].status == H_OBJLIST)
#define MALLOC(dtype, n)	(dtype *)malloc(n*sizeof(dtype))
#define REALLOC(p,dtype, n)	(dtype *)realloc(p, n*sizeof(dtype))

#define ERRNO(v)  	simbad_errno_value = v
#define ERRMSG(t)       simbad_err_text = t

#define ERR_TELECOM     1
#define ERR_SERVER      2
#define ERR_CLIENT      3
#define ERR_SIMBAD     11

#define H_FREE          0
#define H_NODATA        1
#define H_OBJECT        4
#define H_LIST          5
#define H_OBJLIST       6

#define APPLI_ENVAR_NAME  "SIMBAD_APPLI"
#define DEF_APPLI_NAME    "simcli"

static SMB_HANDLE smb_handle[MAX_HANDLES] ;
static int init = NO ;

static char *srv_txt ;
static int srv_code ;
static int srv_len ;
static int simbad_errno_value = 0 ;
static char *simbad_err_text = NULL ;
static char appli_name[8] = "" ;

static int simbad_exch();

/*============================================================================
 *		General Utility Routines
 *============================================================================*/
static int strloc(str, c)
/*+++++++
.PURPOSE Locate the first occurence of character \`c'
.RETURNS Index of \`c' in str; length of str if \`c' not found.
---------*/
  char *str;	/* IN: string to scan	*/
  char c;	/* IN: char to locate	*/
{
  register char *p;

    for (p=str; *p; p++)
  	if (*p == c)	break;
    return(p-str);
}
static char *strsave(str)
	char *str ;
{
	char *newstr ;
	newstr = (char *) malloc(strlen(str)+1) ;
	strcpy(newstr,str) ;
	return(newstr) ;
}

static int CompareTypes(s1, s2)
/*++++++++++++++++
.PURPOSE  Compare First word (followed by a blank) of 2 strings
.RETURNS  Difference (0 = types agree)
-----------------*/
  char *s1;	/* IN: String to compare */
  char *s2;	/* IN: String to compare */
{
  int diff;
    for (diff = 0; diff == 0; s1++, s2++) {
	diff = *s1 - *s2;
	if (isspace(*s1)) break;
    }
    return(diff);
}

/*============================================================================
 *		Send Options to the Server
 *============================================================================*/
static int SendOptions(hno, param, str)
/*++++++++++++++++
.PURPOSE  Send option(s) made of  O\$param_[name] value(s)
.RETURNS  0 / -1 (Error)
.REMARKS  Examples: 
	param = "O.UBV", str="data=M"          ==> send "OO_data M"
	param = "",   str="bibyears=1992/1995" ==> send "O_bibyears 1992/1995"
-----------------*/
  int hno;	/* IN: Simbad Handle number */
  char *param;	/* IN: Data type (e.g. O for Observation, _ for Query */
  char *str;	/* IN: String with [param=]value */
{
  char buf[128], *b;
  char *o, e;
  int len, eq, st;

	/* Construct O\$param_ */
    b = buf; *(b++) = 'O'; *(b++) = '0';
    while (isalnum(*param)) *(b++) = *(param++);

	/* Split str into pieces separated by semi-colons */
    while(*str) {
	while (isspace(*str)) str++;
	len = strloc(str, ';');
	if (len == 0) { str++; continue; }
	o = b;
	e = str[len]; str[len] = 0;		/* Remove the ; */
	if (!*str) continue;
	eq = strloc(str, '=');
	if (str[eq]) {				/* There is an = sign */
	    while (*str != '=') *(o++) = *(str++);
	    str++;	/* Skip the = */
	    while (isspace(*str)) str++;
	}
	if (o[-1] != ' ') *(o++) = ' ';
	len = strlen(str) + (o-buf);
	if (len < sizeof(buf)) strcpy(o, str);
	st = simbad_exch(hno, buf);		/* Send the Question  */
	str += strlen(str);
	if (e) *(str++) = e;
	if (st != OK)	return (-1);
    }
    return (0);
}

/*============================================================================
 *		Routines dealing with SMB_DATA
 *============================================================================*/

static int ClearData(data)
/*++++++++++++++++
.PURPOSE  Clear the data buffer
.RETURNS  0
-----------------*/
  SMB_DATA *data;	/* IN: Buffer to clear */
{
    data->ubuf = data->uline = data->utype = 0;
    data->obuf = data->oline = data->otype = 0;
    *(data->dtype) = 0;
    *(data->query) = 0;
    *(data->tell) = 0;
    return(0);
}

static SMB_DATA *NewData(handle)
/*++++++++++++++++
.PURPOSE  Create new SMB_DATA structure with defaults
.RETURNS  Filled structure
.REMARKS  NULL if fails
-----------------*/
  int handle;	/* IN: Associated handle number */
{
  SMB_DATA *data;
    data = MALLOC(SMB_DATA, 1);
    data->handle = handle;
    data->abuf  = DATABUF ; data->buf  = MALLOC(char, data->abuf);
    data->aline = DATALINE; data->line = MALLOC(int, data->aline);
    data->atype = DATATYPE; data->type = MALLOC(int, data->atype);
    data->aquery = 64; data->query = MALLOC(char, data->aquery);
    data->atell = MAXITYPE*16; data->tell  = MALLOC(char, data->atell);
    ClearData(data);
    return(data);
}

static int KillData(data)
/*++++++++++++++++
.PURPOSE  Free allocated data buffer
.RETURNS  0
-----------------*/
  SMB_DATA *data;	/* IN: Buffer to clear */
{
    free(data->buf);
    free(data->line);
    free(data->type);
    free(data->query);
    free(data->tell);
    free(data);
    return(0);
}

static int AddData(data, str)
/*++++++++++++++++
.PURPOSE  Append data into buffer, update related info
.RETURNS  0
-----------------*/
  SMB_DATA *data;  /* IN: Buffer to clear */
  char *str;	  /* IN: Data made of lines, 1st word of each = datatype */
{
  int len, n;
  char *p, *b, *t;

    len = strlen(str); 

	/* 1) Append string to existing ones */
    n = data->ubuf + len;
    if (n >= data->abuf) {	/* Have to expand buffer ... */
	n = (n + DATABUF - 1) / DATABUF;
	data->abuf = n * DATABUF;
	data->buf = REALLOC(data->buf, char,  data->abuf);
    }
    strcpy(data->buf + data->ubuf, str);
    data->obuf = data->ubuf;
    data->ubuf += len;

	/* 2) Set the array of line beginnings & Data Types */
    t = data->utype > 0 ? 
	data->buf + data->line[data->type[data->utype-1]] 
        : " ";
    for (b = data->buf + data->obuf; ; b = p ) { 
	p = strchr (b, '\\n');
	if (!p) break;
	*(p++) = 0;	/* Replace the \\n */
	if (isspace(*b)) continue;	/* Empty or useless line */
	if (!strchr(b, ' ')) continue;	/* No space in line ==> No data... */
	if (data->uline >= data->aline) {	/* Have to expand line array */
	    data->aline += DATALINE;
	    data->line = REALLOC(data->line, int, data->aline);
	}
	data->line[data->uline] = b - data->buf;
	if (CompareTypes(t, b)) {		/* New Data Type */
	    if (data->utype >= data->atype-1) {	/* Have to expand... */
		data->atype += DATATYPE;
		data->type = REALLOC(data->type, int, data->atype);
	    }
	    data->type[data->utype] = data->uline;
	    data->utype += 1;
	    t = b;
	}
	data->uline += 1;
    }
    data->obuf = b - data->buf;
    data->type[data->utype] = data->uline;	/* Last line */

    return(0);
}

static int TellData(data)
/*++++++++++++++++
.PURPOSE  Prepare the "tell" substructure filled with existing astrotypes
.RETURNS  Number of different astrotypes (number of words in data->tell)
-----------------*/
  SMB_DATA *data; /* IN: Buffer to clear */
{
  int n, i, *it; 
  char *o, *p, *at;

    o = data->tell; 

	/* Find out the line starting with dtype */
    for (it = data->type, i = data->utype; --i >= 0; it++) {
	at = data->buf + data->line[*it];	/* Data Type */
	for (p = at; isgraph(*p); p++) ;
	n = p - at + 1;
	if (((o-data->tell) + n) >= data->atell) {	/* Must expand ... */
	    data->atell += MAXITYPE*4;	/* Prepare room for 4 types */
	    data->tell = REALLOC(data->tell, char, data->atell);
	}
	if (*at == '#') {	/* We've a number of data. */
	    if (!atoi(p)) continue;	/* Counter indicates 0 */
	    at++, n--;
            if (*at == 'O') at[(--n)-1] = ' ' ;    /* replace colon by space */
	}
	strncpy(o, at, n);			/* Copy including blank */
	o += n;
    }
    if (o > data->tell) {
	o--;
    	if (isgraph(*o)) o++;
    }
    *o = 0;					/* Terminate string */
    return(data->utype);	/* This is the number of different data types */
}

static int FindData(data, dtype)
/*++++++++++++++++
.PURPOSE  Find data in buffer
.RETURNS  Number of existing dtypes
-----------------*/
  SMB_DATA *data; /* IN: Buffer to clear */
  char *dtype;	  /* IN: Data astrotype to look for */
{
  char *b, *p, buf[MAXITYPE+3];
  int i, h, diff, *t;
   /*static int first;  */

    *(data->query) = 0;
    i = strlen(dtype); 
    if (i > MAXITYPE) return(0);	/* Too long datatype */
    b = dtype + i - 1;
    if (*b != ' ') i++;
    strcpy(data->dtype, dtype);
    if (*b != ' ') strcat(data->dtype, " ");

	/* Loop over lines received from Server; 
	   h indicates the number of data found from # */
    buf[0] = '#'; strcpy(buf+1, data->dtype);
    data->otype = -1; 
    h = 0;
    for (t = data->type, i = data->utype; --i >= 0; t++) {
	b =  data->buf + data->line[*t];
	if (*b == '#') {
	    if (h > 0) continue;		/* # already found   */
	    diff = CompareTypes(buf, b);
	    if (diff == 0) { char *q;		/* Found with #      */
		q = data->query; *(q++) = 'Q';
		for (p = b; isgraph(*p); p++, q++) 
		    *q = isalnum(*p) ? *p : '0' ;
		*q = 0;
		h = atoi(p);			/* Number (2nd word) */
	    }
	    continue;
	}
	diff = CompareTypes(buf+1, b);
	if (diff == 0) break;			/* Found without #   */
    }

    if (i >= 0)	{			/* Data were found without # */
	*data->query = 0;
	data->otype = t - data->type;	/* Agree */
	data->oline = *t;		/* First Line */
	if (h <= 0) h = t[1] - t[0];	/* This gives the number of lines */
	return (h);
    }
    if (h <= 0)  		   /* #Data was found with 0 data... */
	*data->query = 0; 

    return(h);
}

static char *GetData(data, number)
/*++++++++++++++++
.PURPOSE  Find numbered data in buffer
.RETURNS  String with data / NULL string
-----------------*/
  SMB_DATA *data; /* IN: Buffer to clear */
  int number;	  /* IN: Number in range 1...n */
{
  char *p;
  int  *t;
    if (*data->query) {		/* There is a query to perform. Do it ! */
	simbad_exch(data->handle, data->query);
	FindData(data, data->dtype);
	*data->query = 0;
    }
    if (data->otype < 0) return(NULL);
    if (number <  0) return(NULL);
    t = data->type + data->otype;
    if (number == 0) data->oline += 1;
    else data->oline = *t + number;
#ifdef DEBUG
    printf(".... GetData number=%d (oline=%d), limites=[%d,%d]\\n", 
	number, data->oline, t[0], t[1]);
#endif

    if (data->oline > t[1]) return(NULL);
    p = data->buf + data->line[data->oline-1];
    if (CompareTypes(data->dtype, p)) {
#ifdef DEBUG
	printf("++++ GetData, type disagree dtype=%s, found=%s\\n", 
		data->dtype, p);
#endif
	return(NULL);
    }
    p = strchr(p, ' ');
    if (!p) p++;
    return(p);
}


static int noresult(ps)
	SimDatStruct *ps ;
{
	srv_txt = ps->msg ;
	srv_code = ps->code ;
	srv_len  = ps->length;
}

static int fresult(ps)
	SimDatStruct *ps ;
{
	srv_txt = ps->msg ;
	srv_code = ps->code ;
	srv_len  = ps->length;
}

static int simbad_send(hand,str)
	int hand ;
	char *str ;
{
  int st;
	st = ClientTreat(smb_handle[hand].sock,str,noresult);
#ifdef DEBUG
       	printf("SENT    <%s> st=%d, code=%d, length=%d. Received Text:\\n%s\\n",
		    str, st, srv_code,srv_len,srv_txt);
#endif
	return(OK) ;
}

static int simbad_exch(hand,str)
	int hand ;
	char *str ;
{
  char *msg;
  int st;
#ifdef DEBUG
	printf("EXCH: handle=%d (socket=%d)\\n%s\\n",
		hand,smb_handle[hand].sock,str) ;
#endif
	/* ClientTreat returns NOEND if the answer is not complete... */
	for (msg=str; msg; ) {
	    st = ClientTreat(smb_handle[hand].sock,msg,fresult);

#ifdef DEBUG
       	printf("RECV to <%s> st=%d, code=%d, length=%d. Text:\\n%s(Hit Return)",
		    msg, st, srv_code,srv_len,srv_txt);
	getchar();
#endif
	    if (srv_code == UIF_ERROR)
	    {
		if (smb_handle[hand].errormsg != NULL)
			free(smb_handle[hand].errormsg) ;
		smb_handle[hand].errormsg = (char *) malloc(strlen(srv_txt)+1);
		strcpy(smb_handle[hand].errormsg,srv_txt) ;
	    }
	    else
	    {
#define REF_INTRO "SIMBAD reference code: "
		char *p = srv_txt ;
		if (msg == str &&
		    strlen(srv_txt) > sizeof(REF_INTRO) &&
		    strncmp(srv_txt,REF_INTRO,sizeof(REF_INTRO)-1) == 0)
		{
			while(*p && *p != '\\n') p++ ;
			p++ ;
		}
		AddData(smb_handle[hand].answer, p) ;
	    }
	    if (st == NOEND) msg  = "";
	    else msg = (char *)0;

	}
	smb_handle[hand].answertype = srv_code ;

	return(OK) ;
}

static int simbad_open(hand,node,service,userid,passwd,appli)
	int hand ;
	char *node ;
	char *service ;
	char *userid ;
	char *passwd ;
	char *appli ;
{
	int s ;

	s = ClientOpen(noresult,node,service,userid,passwd,appli) ;

	if (s > 0)
	{
		smb_handle[hand].sock = s ;
		return(OK) ;
	}
	else
		return(s) ;
}


static int simbad_close(hand)
	int hand ;
{
	ClientClose(smb_handle[hand].sock) ;
	return(OK) ;
}

static int simbad_endquery(hand)
	int hand ;
{
	if (! isopen(hand))
	{
		ERRNO(ERR_CLIENT) ;
		ERRMSG("Handle not opened") ;
		return(ERROR) ;
	}

	simbad_send(hand,"simbad search") ;
	smb_handle[hand].nbobj = 0 ;
	if (smb_handle[hand].question != NULL)
	{
		free(smb_handle[hand].question) ;
		smb_handle[hand].question = NULL ;
	}
	ClearData(smb_handle[hand].answer);
	if (smb_handle[hand].errormsg != NULL)
	{
		free(smb_handle[hand].errormsg) ;
		smb_handle[hand].errormsg = NULL ;
	}
	smb_handle[hand].status = H_NODATA ;

	return(OK) ;
}

/*============================================================================
 *		Routines dealing with SMB_HANDLE
 *============================================================================*/
int simbad_connect(node,service,userid,passwd)
/*++++++++++++++++
.PURPOSE  Connect to Simbad
.RETURNS  The "Simbad-Handle" Number / -1 if Error
-----------------*/
	char *node ;
	char *service ;
	char *userid ;
	char *passwd ;
{
	int i ;
	int hand, sock ;
	int stat ;
	char *NODE, *SERVICE ;

	/* initialize the handle list */
	if (! init)
	{
		for (i=0 ; i < MAX_HANDLES ; i++)
		{
			smb_handle[i].question = NULL ;
			smb_handle[i].answer = (SMB_DATA *)0;
			smb_handle[i].errormsg = NULL ;
			smb_handle[i].status = H_FREE ;
		}
		init = YES ;
	}

	/* suppress sk_io error display */
	sk_setlog(NULL) ;

	/* look for a free handle */
	for (hand=0 ; hand < MAX_HANDLES ; hand++)
		if (smb_handle[hand].status == H_FREE) break ;
	if (hand >= MAX_HANDLES)
	{
		ERRNO(ERR_CLIENT) ;
		ERRMSG("Max number of handles opened") ;
		return(ERROR) ;
	}

	if (! smb_handle[hand].answer) 
		smb_handle[hand].answer = NewData(hand);

	/* open the connection */
	NODE = (node==NULL || *node==EOS) ? DEFAULT_NODE : node ;
	SERVICE = (service==NULL || *service==EOS) ? DEFAULT_SERVICE : service ;
	simbad_appli(NULL) ;
	if ((stat = simbad_open(hand,NODE,SERVICE,userid,passwd,appli_name)) < 0)
	{
		smb_handle[hand].status = H_FREE ;
		hand = ERROR ;
		ERRNO(stat == -2 ? ERR_CLIENT : ERR_TELECOM) ;
		ERRMSG("The client version or application name is not accepted by the server") ;
		return(ERROR) ;
	}
	smb_handle[hand].status = H_NODATA ;

	/* send the macro setting the right parameters */
	simbad_send(hand,"simclifmt") ;

	return(hand) ;
}

int simbad_disconnect(hand)
	int hand ;
{
	int stat ;

	if (! isopen(hand))
	{
		ERRNO(ERR_CLIENT) ;
		ERRMSG("Handle not opened") ;
		return(ERROR) ;
	}

	simbad_send(hand,"simbad-reflist reset") ;
	simbad_send(hand,"session exit") ;

	stat = simbad_close(hand) ;

	if (smb_handle[hand].question != NULL)
	{
		free(smb_handle[hand].question) ;
		smb_handle[hand].question = NULL ;
	}
	if (smb_handle[hand].answer != NULL)
	{
		KillData(smb_handle[hand].answer);
		smb_handle[hand].answer = NULL ;
	}
	if (smb_handle[hand].errormsg != NULL)
	{
		free(smb_handle[hand].errormsg) ;
		smb_handle[hand].errormsg = NULL ;
	}
	smb_handle[hand].status = H_FREE ;

	return(stat) ;
}

int simbad_query(hand,question,options)
	int hand ;
	char *question ;
	char *options ;
{
	int minlg ;

	if (! isopen(hand))
	{
		ERRNO(ERR_CLIENT) ;
		ERRMSG("Handle not opened") ;
		return(ERROR) ;
	}

	/* the previous query is ended */
	simbad_endquery(hand) ;

	/* Send Options */
	if (options) {
		if (SendOptions(hand, "", options) < 0)
			return(ERROR);
	}

	/* Return if question is empty */
	if (!*question) return(0) ;

	/* Save the question request */
	smb_handle[hand].question = strsave(question) ;

	/* Send the question and get the answer */
	simbad_exch(hand,question) ;

	/* the answer can be (see srv_code):
	 *   of type UIF_LIST, wich needs to extract the number of objects
	 *   of type UIF_DATA, which correspond to a data string for an unique
         *                     object to put in the handle struct.
	 *   of type UIF_ERROR,in which case, the error message is in the
	 *                     handle structure.
	 */

	/* Examine the returned code
	 */
	if ((minlg = smb_handle[hand].answer->ubuf) > 4) minlg = 4 ;
	switch(srv_code) {
	  case UIF_ERROR:
		ERRNO(ERR_SIMBAD) ;
		return(ERROR) ;
	  case UIF_LIST:
#if 0
	    strncmp(smb_handle[hand].answer->buf,"====",minlg) == 0 ||
	    strncmp(smb_handle[hand].answer->buf,"Numb",minlg) == 0)
#endif
	    {
		char *p ;

		/* Object list build on server side
		 * The number of object is the last number in the result string
		 */
		for (p = srv_txt + strlen(srv_txt) - 1 ;
		     p >= srv_txt && ! isdigit(*p) ;
		     p--) ;  /* go backwards to the last digit */
		while(p >= srv_txt && isdigit(*p)) p-- ;
			     /* go backwards to the beginning of the number */
		if (p < srv_txt)
		{
			ERRNO(ERR_SERVER) ;
			ERRMSG("Incorrect object list header send by the server") ;
			return(ERROR) ;
		}
		p++ ;
		smb_handle[hand].nbobj = atoi(p) ;
		smb_handle[hand].objnum = 0 ;
		smb_handle[hand].status = H_LIST ;
		ClearData(smb_handle[hand].answer) ;
	    }
	    break;
	  case UIF_EMPTYLIST:
		smb_handle[hand].nbobj = 0;
		smb_handle[hand].objnum = 0 ;
		break;
	  default:
		/* Data received directly */
		smb_handle[hand].nbobj = 1 ;
		smb_handle[hand].objnum = 0 ;
		smb_handle[hand].status = H_OBJECT ;
	}
	return(smb_handle[hand].nbobj) ;
}

int simbad_retrieve(hand,num)
	int hand ;
	int num ;
{
	char str[32] ;

	if (! isopen(hand) || ! existdata(hand)) 
	{
		ERRNO(ERR_CLIENT) ;
		ERRMSG("Handle not opened, or no object available") ;
		return(ERROR) ;
	}

	/* compute the right object number */
	if (num == 0) smb_handle[hand].objnum++ ;
	else          smb_handle[hand].objnum = num ;
	if (smb_handle[hand].objnum <= 0 || 
	    smb_handle[hand].objnum > smb_handle[hand].nbobj) return(0) ;
#ifdef DEBUG
	printf("RETRIEVE: objnum=%d, status=%d\\n",
		smb_handle[hand].objnum,smb_handle[hand].status) ;
#endif

	/* put the standard data in the handle answer string */
	switch(smb_handle[hand].status)
	{
		case H_OBJECT: /* single object already on client side */
		break ; /* nothing to do */

		case H_OBJLIST: /* an object in the list is current */
		ClearData(smb_handle[hand].answer) ;
		simbad_send(hand,"bye") ; /* comes back to the list object */
		smb_handle[hand].status = H_LIST ;
		/* no break: must continue with the next case */

		case H_LIST:    /* the server is at the list prompt */
		sprintf(str,"%d",smb_handle[hand].objnum) ;
		simbad_exch(hand,str) ;
#if 0
		smb_handle[hand].status = H_OBJLIST ;
#else /*****FO**** PROBLEM WITH EMPTY RESULT: no BYE !!! */
		smb_handle[hand].status =
			(smb_handle[hand].answer)-> ubuf ? H_OBJLIST : H_LIST;
#endif
		break ;

		default:        /* should not happen */
		ERRNO(ERR_SERVER) ;  /*  ??? Error from the UIF class */
		ERRMSG("Bad data code returned by the server") ;
		return(ERROR) ;
	}
	return(smb_handle[hand].nbobj - smb_handle[hand].objnum + 1) ;
}

char *simbad_telldata(hand)
  int hand;		/* IN: Simbad Connection number */
{
    if (! isopen(hand) || ! existdata(hand)) return(NULL) ;
    TellData(smb_handle[hand].answer);
    return((smb_handle[hand].answer)->tell);
}
  
int simbad_findata(hand, astrotype, options)
  int hand;		/* IN: Simbad Connection number */
  char *astrotype;	/* IN: Data type to look at */
  char *options;	/* IN: Option string        */
{
    if (! isopen(hand) || ! existdata(hand))
    {
	ERRNO(ERR_CLIENT) ;
	ERRMSG("Handle not opened, or no object available") ;
	return(ERROR) ;
    }

    	/* Send Options */
    if (options) {
	if (SendOptions(hand, astrotype, options) < 0)
	    return(ERROR);
    }
    return(FindData(smb_handle[hand].answer, astrotype));
}

char *simbad_getdata(hand, number)
  int hand;		/* IN: Simbad Connection number */
  int number;		/* IN: Number (0 = Next)    */
{
    if (! isopen(hand) || ! existdata(hand))
    {
	ERRNO(ERR_CLIENT) ;
	ERRMSG("Handle not opened, or no object available") ;
	return(NULL) ;
    }
    return(GetData(smb_handle[hand].answer, number));
}

char *simbad_error(h)
	int h ;
{
	switch(simbad_errno_value)
	{
		case ERR_TELECOM:
			return(sk_error()) ;
		case ERR_SERVER:
		case ERR_CLIENT:
			return(simbad_err_text) ;
		case ERR_SIMBAD:
			return(smb_handle[h].errormsg) ;
		default:
			return("Unknown error code") ;
	}
}


int simbad_errno()
{
	return(simbad_errno_value) ;
}


int simbad_appli(str)
	char *str ;
{
	char *p ;

	if (str && *str)
		p = str ;
	else 
		/* Initialisation by env. variable or default name */
		if ((p = getenv(APPLI_ENVAR_NAME)) == NULL)
			p = DEF_APPLI_NAME ;
	strncpy(appli_name,p,sizeof(appli_name)-1) ;
	appli_name[sizeof(appli_name)-1] = '\\0' ;
}

%%END%%
echo ==== ./uifclient.c
cat << %%END%% > ./uifclient.c
/****************************************************************************/
/*                      MODULE: client.c                                    */
/*                                                                          */
/* ROLE : Fonctions permettant de dialoguer avec le serveur de SIMBAD       */
/*                                                                          */
/* IMPORTATION :                                                            */
/*               libsk.a						    */
/*                                                                          */
/* EXPORTATIONS :                                                           */
/*                                                                          */
/* FONCTIONS LOCALES :                                                      */
/*                                                                          */
/* AUTEURS : Eric DIVETAIN ( Observatoire astronomique de Strasbourg )      */
/*                                                                          */
/* DATE DE CREATION : 15/07/93                                              */
/*                                                                          */
/* MODIFICATIONS :							    */ 
/*   MW - fev 94 :							    */
/*	envoi d'un code application et d'un numero de version		    */
/*   MW - mar 94 :							    */
/*      Bug dans ClientTreat(): return d'une valeur si appel recursif	    */
/*	Transfo de ClientTransFile() en ClientSendFile()		    */
/*	et rajout de ClientRcvFile()					    */
/*   FO - Jun 95: allow ANSI                                                */
/*   MW - Dec 95: initialize buffer = NULL                                  */
/*                                                                          */
/****************************************************************************/
/* Versions:
	V300: debut fev 94  - version temporarire transmise a dao et eso
	V310: 1-mar-94      - version diffusee au 1/3/94
	V320: 7-mar-94      - version avec ClientSendFile() et ClientRcvFile()
	V321: 20-jun-95     - TestVersionAppli
*/

#define VERSION "V320"

#ifndef _PARAMS
#ifdef __STDC__
#define _PARAMS(A)      A       /* ANSI */
#else
#define _PARAMS(A)      ()      /* Traditional */
#endif
#endif

/****************************************************************************/
/* INCLUDES SYSTEMES                                                        */
/****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <signal.h>
#include <errno.h>

/****************************************************************************/
/* INCLUDES UTILISATEUR                                                     */
/****************************************************************************/
#include <simclic.h>

/****************************************************************************/
/* CONSTANTES                                                               */
/****************************************************************************/
#define FBUF 100
#define	HEAD_BUF 8		/* Taille de l'entete des chaines echangees */
#define OKSUITE "OKSUITE"	/* utilise dans ClientTreat() */
#define PASUITE "PASUITE"
#define AGAIN	"AGAIN"
#define UIF_CONTROLE	20	/* Code de controle interne a l'uif */

#define CODSIMBAD "1"
#if 0
#define CODTRANFI "3"
#endif
#define CODSENDFI "3"
#define CODRCVFI  "4"

/****************************************************************************/
/* VARIABLES                                                                */
/****************************************************************************/
static char *sendstring; /* Pointeur sur la chaine a envoyer ClientSend() */
static int stringsize = 0;/* Longueur de la chaine a envoyer ClientSend() */
static char *buffer = NULL;	/* Pointeur sur le buffer recu ClientGet() */
static int  bufsize = 0;/* Longueur de la chaine recue ClientGet() */
static char dirpath[256];
static char statserveur[128];
static char statservice[32];
static char statname[32];
static char statpasswd[32];

/****************************************************************************/
/* FONCTIONS IMPORTEES                                                      */
/****************************************************************************/
/* Library: /usr/local/lib/libsk.a */
extern int sk_connect   _PARAMS((char *machine, char *service,
			char *username, char *password));
extern int sk_puts     _PARAMS((int plug, char *buf));
extern int sk_get      _PARAMS((int plug, char *buf, int len));
extern int sk_gets     _PARAMS((int plug, char *buf, int len));
extern int sk_close    _PARAMS((int plug));

/****************************************************************************/
/* FONCTIONS LOCALES                                                        */
/****************************************************************************/

/****************************************************************************/
/* FONCTION :                                                               */
/*	int ClientSend( ear, ask_string )				    */
/* PRAMETRES :                                                              */
/*      -ENTREES :                                                          */
/*		int ear: numero de socket				    */
/*		char *ask_string : requete				    */
/*      -SORTIES :                                                          */
/*		retourne: OK, ERROR, CONNEXIONERROR			    */
/* ROLE :                                                                   */
/*--------------------------------------------------------------------------*/
/* Realisation :                                                            */
/*	Cette fonction permet d'envoyer une chaine de caractere associee    */
/* a la structure SimDatStruct (client.h)				    */
/****************************************************************************/

static int ClientSend( ear, askstring )

	int
		ear;
	char
		*askstring;
{
	int
		asksize;

	asksize = strlen( askstring );
	if( asksize + HEAD_BUF + 1 >= stringsize )
	{
		if( stringsize != 0 ) 
		{
			free(sendstring);
		}
		stringsize = asksize + HEAD_BUF + 1;
		stringsize = (stringsize+511)&~511;

		sendstring = malloc( stringsize );
		if( sendstring == NULL )
		{
			perror("malloc() in ClientSend()");
			return( ERROR );
		}
	}
	sprintf(sendstring,"%c%c%6d%s", '*','*', asksize, askstring);

	if( sk_put( ear, sendstring ) == ERROR )
	{
		return( CONNEXIONERROR );
	}
	return( OK );
}

/****************************************************************************/
/* FONCTION : ClientGet                                                     */
/* PRAMETRES :                                                              */
/*      -ENTREES : 							    */	
/*		int ear : numero de socket                                  */
/*		SimDatStruct getstruct : structure initialisee		    */
/*      -SORTIES :                                                          */
/*		retourne : OK, CONNEXIONERROR, NOEND                        */
/* ROLE :								    */
/* 	Cette fonction recupere la chaine de caractere se trouvant sur le   */
/* socket ear et initialise la structure getstruct                          */
/*--------------------------------------------------------------------------*/
/* Realisation :                                                            */
/****************************************************************************/

static int ClientGet( ear, getstruct )
	int
		ear;
	SimDatStruct
		*getstruct;
{

	char
		head_string[HEAD_BUF + 1],
		type[3],
		flag;
	int
		lenght = 0;

	getstruct->msg = 0;

	if( sk_get( ear, head_string, HEAD_BUF ) == ERROR )
	{
		return( CONNEXIONERROR );
	}
	head_string[HEAD_BUF] = '\\0';

	type[0] = head_string[0];
	type[1] = head_string[1];
	type[2] = '\\0';
	getstruct->code =  atoi(type);
	flag = head_string[2];

	lenght = atoi( &(head_string[3]) );
	getstruct->length = lenght;

	if (lenght >= bufsize)
	{
		if(buffer)
		{
			free(buffer);
		}

		bufsize = lenght + 8 ;
	    	bufsize = (bufsize+511)&~511;

	    	buffer = malloc(bufsize);
	    	if( buffer == NULL )
	    	{
			perror("malloc() in ClientGet()");
			return( ERROR );
	    	}
	}
	getstruct->msg = buffer;

	if( sk_get( ear, getstruct->msg, lenght) == ERROR )
	{
		return( CONNEXIONERROR );
	}
	getstruct->msg[lenght] = '\\0';

	if( flag == 'e' )
	{
		return( OK );
	}
	else if( flag == 's' )
	{
		return( NOEND );
	}
}

/****************************************************************************/
/* FONCTION :	                                                            */
/*	static int ClientConnect( display_fct, host, service, name, passwd )*/
/* PRAMETRES :                                                              */
/*      -ENTREES :                                                          */
/*		char *host: nom du serveur                                  */
/*              char *service: nom du service                               */
/*              char *name: nom different du userid                         */
/*              char *passwd: password                                      */
/*      -SORTIES :                                                          */
/*		void (*display_fct)(): Fonction de traitement des messages  */
/*		retourne: ERROR ou ear (numero de socket)		    */
/* ROLE :                                                                   */
/*	Cette fonction permet de se connecter au serveur de SIMBAD, et      */
/* retourne le numero de socket                                             */
/*--------------------------------------------------------------------------*/
/* Realisation :                                                            */
/****************************************************************************/

static int ClientConnect( display_fct, host, service, name, passwd )
	void
		(*display_fct)();
	char
		*host,
		*service,
		*name,
		*passwd;
{
	int
		ear;
	SimDatStruct
		teststruct;

	teststruct.code = 0;
	teststruct.msg = 0;
	teststruct.length = 0;

	ear = sk_connect( host, service, name, passwd );
	if( ear < 0 )
	{
		teststruct.code = UIF_CONNEXIONERROR;
		teststruct.msg = ERR_SOCKET;
		if( display_fct != NULL )
		{
			display_fct( &teststruct );
		}
		return( ERROR );
	}
	return( ear );
}

/****************************************************************************/
/* FONCTION :                                                               */
/*	int ClientOpen( display_fct, host, service, name, passwd, appli )   */
/* PRAMETRES :                                                              */
/*      -ENTREES :                                                          */
/*		char *host: nom du serveur 				    */
/*		char *service: nom du service 				    */
/*		char *name: nom different du userid 			    */
/*		char *passwd: password					    */	
/*		char *appli: nom de l'application			    */
/*      -SORTIES :                                                          */
/*		void (*display_fct)(): Fonction de traitement des messages  */
/*		retourne: ERROR ou BAD_VERSION ou ear (numero de socket)    */
/* ROLE :                                                                   */
/*	Cette fonction permet de se connecter au serveur de SIMBAD, et      */
/* transmet le motd a l'aide de la fonction 'display_fct()' qui a pour      */
/* argument l'adresse d'une structure du type 'SimDatStruct'                */
/* ( voir client.h ). Cette fonction envoie le code associe au service      */
/* SIMBAD		                                                    */	
/*--------------------------------------------------------------------------*/
/* Realisation :                                                            */
/****************************************************************************/

int ClientOpen( display_fct, host, service, name, passwd, appli )
	void
		(*display_fct)();
	char
		*host,
		*service,
		*name,
		*passwd,
		*appli;
{
	SimDatStruct
		getstruct,
		welcome_msg;
	int
		ear;

	strcpy( statname, name);
	strcpy( statpasswd, passwd);
	strcpy( statserveur, host);
	strcpy( statservice, service);
	welcome_msg.code = 0;
	welcome_msg.msg = 0;
	welcome_msg.length = 0;

	ear = sk_connect( host, service, name, passwd );
	if( ear < 0 )
	{
		welcome_msg.code = UIF_CONNEXIONERROR;
		welcome_msg.msg = ERR_SOCKET;
		welcome_msg.length = L_ERR_SOCKET;
		if( display_fct != NULL )
			display_fct( &welcome_msg );
		return( ERROR );
	}

	if (TestVersionAppli(ear,display_fct,appli) != OK)
		return(BAD_VERSION) ;

	if( ClientSend( ear, CODSIMBAD ) < 0 )
	{
		welcome_msg.code = UIF_CONNEXIONERROR;
		welcome_msg.msg = ERR_WRITE;
		welcome_msg.length = L_ERR_WRITE;
		if( display_fct != NULL )
			display_fct( &welcome_msg );
		return( ERROR );
	}

	if( ClientGet( ear, &welcome_msg) < 0 )
	{
		welcome_msg.code = UIF_CONNEXIONERROR;
		welcome_msg.msg = ERR_READ;
		welcome_msg.length = L_ERR_READ;
		if( display_fct != NULL )
			display_fct( &welcome_msg );
		return( ERROR );
	}
	strcpy( dirpath, welcome_msg.msg);

	if( ClientGet( ear, &welcome_msg) < 0 )
	{
		welcome_msg.code = UIF_CONNEXIONERROR;
		welcome_msg.msg = ERR_READ;
		welcome_msg.length = L_ERR_READ;
		if( display_fct != NULL )
			display_fct( &welcome_msg );
		return( ERROR );
	}

	if( display_fct != NULL )
		display_fct( &welcome_msg );

	return( ear );
}

/****************************************************************************/
/* FONCTION :                                                               */
/*	int ClientTreat( ear, askstring, display_fct, code )		    */
/* PRAMETRES :                                                              */
/*      -ENTREES :                                                          */
/*		int ear : numero de socket				    */
/*		char *askstring : pointeur sur la requete		    */
/*		void (*display_fct)() : fonction d'affichage 		    */
/*		int code : argument de la fonction display_fct()	    */
/*      -SORTIES :                                                          */
/*		retourne : OK, CONNEXIONERROR, NOEND			    */
/* ROLE :                                                                   */
/*	Cette fonction envoie la requete 'askstring' au serveur et renvoie  */
/* le resultat a travers la fonction 'display_fct()' qui a pour argument    */
/* l'adresse d'une structure du type 'SimDatStruct' (Server.h)   	    */
/*--------------------------------------------------------------------------*/
/* Realisation :                                                            */
/****************************************************************************/

int ClientTreat( ear, askstring, display_fct, code )
	int
		ear;
	char
		*askstring;
	void
		(*display_fct)();
	int
		code;
{
	int
		suite;

	SimDatStruct
		getstruct;

	if( strcmp( askstring, "" ) == 0 )
	{
		askstring = OKSUITE;
	}

	if( ClientSend( ear, askstring ) < 0 )
	{
		return( CONNEXIONERROR );
	}
	
	suite = ClientGet( ear, &getstruct );

	if( strcmp( getstruct.msg, AGAIN ) == NULL )
	{
		return(ClientTreat( ear, askstring, display_fct, code ));
         /* ??? return rajoute ici sinon aucune valeur n'est retournee lorsqu'on
            passe ici. Ceci se produit lors d'une reponse 'no' a
            'do you want to see more ?' dans une longue liste. Avec plantage
            sur sun si module client.c compile avec -O[2]. DEC ne plante pas,
            mais cela ne doit venir que du fait que c'est par hasard 0 qui est
            retourne. */
         /* essayer de supprimer la recursivite ... ??? */
	}
	else
	{
		display_fct( &getstruct, code );
		return( suite );
	}
}

/****************************************************************************/
/* FONCTION :                                                               */
/*		void ClientClose( ear )					    */
/* PRAMETRES :                                                              */
/*      -ENTREES :                                                          */
/*		int ear: numero de socket				    */
/*      -SORTIES :                                                          */
/* ROLE :                                                                   */
/*	Cette fonction libere le socket ear				    */
/*--------------------------------------------------------------------------*/
/* Realisation :                                                            */
/****************************************************************************/

void ClientClose( ear )
	int
		ear;
{
#if 1
	sk_close( ear );
#else
	shutdown(ear,2);
#endif
}

/***********************************************************************

 NAME CLientSendFile( )

 DESCRIPTION

	Cette fonction permet de lire un fichier dans lequel se trouve
un format et de le transmettre au serveur

 RETURN VALUES
	OK/ERROR

************************************************************************/
int ClientSendFile( display_fct, fullname, name, appli )
	void
		(*display_fct)();
	char
		*fullname,
		*name,
		*appli ;
{
	SimDatStruct
		errormsg;
	int
		ear,
		file;
	char
		newname[256];

	errormsg.code = 0;
	errormsg.msg = 0;
	errormsg.length = 0;

	ear = ClientConnect( display_fct, statserveur, statservice, statname, statpasswd );
	if( ear < 0 )
        {
                return( ERROR );
        }

	if (TestVersionAppli(ear,display_fct,appli) != OK)
		return(BAD_VERSION) ;

        if( ClientSend( ear, CODSENDFI ) < 0 )
	{
		errormsg.code = UIF_CONNEXIONERROR;
		errormsg.msg = ERR_WRITE;
		errormsg.length = L_ERR_WRITE;
		display_fct( &errormsg );
		return( ERROR );
	}

	sprintf(newname, "./%s/%s", dirpath, name);
        if( ClientSend( ear, newname ) < 0 )
	{
		errormsg.code = UIF_CONNEXIONERROR;
		errormsg.msg = ERR_WRITE;
		errormsg.length = L_ERR_WRITE;
		display_fct( &errormsg );
		return( ERROR );
	}

	file = open( fullname, 0 );
	if( file < 0 )
	{
		errormsg.code = UIF_OTHERERROR;
		errormsg.msg = ERR_OPEN_FILE;
		errormsg.length = L_ERR_OPEN_FILE;
		display_fct( &errormsg );
		return( ERROR );
	}

	sk_fromserver( ear, 1, file );
	close( file );
        return( OK );
}

/***********************************************************************

 NAME ClientRcvFile( )

 DESCRIPTION

	Cette fonction permet de recevoir n'importe que fichier du serveur

 RETURN VALUES
	OK/ERROR

************************************************************************/
int ClientRcvFile(datatype, display_fct, localfile, distantfile, appli )
	int
		datatype ;
	void
		(*display_fct)();
	char
		*localfile,
		*distantfile,
		*appli ;
{
	SimDatStruct
		errormsg;
	int
		ear,
		file;
	char
		newname[256] ;

	errormsg.code = 0;
	errormsg.msg = 0;
	errormsg.length = 0;

	ear = ClientConnect( display_fct, statserveur, statservice, statname, statpasswd );
	if( ear < 0 )
        {
                return( ERROR );
        }

	if (TestVersionAppli(ear,display_fct,appli) != OK)
		return(BAD_VERSION) ;

        if( ClientSend( ear, CODRCVFI ) < 0 )
	{
		errormsg.code = UIF_CONNEXIONERROR;
		errormsg.msg = ERR_WRITE;
		errormsg.length = L_ERR_WRITE;
		display_fct( &errormsg );
		return( ERROR );
	}

	if (datatype == RCV_FILE)
		strcpy(newname,distantfile) ;
	else if (datatype == RCV_FORMAT)
		sprintf(newname, "../%s.fmt", distantfile);

        if( ClientSend( ear, newname ) < 0 )
	{
		errormsg.code = UIF_CONNEXIONERROR;
		errormsg.msg = ERR_WRITE;
		errormsg.length = L_ERR_WRITE;
		display_fct( &errormsg );
		return( ERROR );
	}

	file = open( localfile, O_CREAT|O_RDWR, 0660 );
	if( file < 0 )
	{
		errormsg.code = UIF_OTHERERROR;
		errormsg.msg = ERR_OPEN_FILE;
		errormsg.length = L_ERR_OPEN_FILE;
		display_fct( &errormsg );
		return( ERROR );
	}

	sk_fromserver( ear, file, 0 );
	close( file );
        return( OK );
}

int TestVersionAppli(ear,display_fct,appli)
        int ear ;
        void (*display_fct)();
        char *appli ;
{
        SimDatStruct
                welcome_msg;
        char
                ctrl_str[256],
                version_ack[8];
        int
                ctrl_str_lg,
                version_ack_lg ;

        /* Envoi "version;appli" et test du numero de version */
        version_ack_lg = sizeof(version_ack) ;
        strcpy(ctrl_str,VERSION) ;
        strcat(ctrl_str,";") ;
        strcat(ctrl_str,appli) ;
        ctrl_str_lg = strlen(ctrl_str)+1 ;  /* +1 for the EOS char !!! */
        if (sk_write(ear, ctrl_str, ctrl_str_lg) != ctrl_str_lg ||
                 sk_read(ear,version_ack,version_ack_lg) <= 0 ||
                 strcmp(version_ack,"OK") != 0)
        {
                welcome_msg.code = UIF_CONNEXIONERROR;
                welcome_msg.msg = ERR_VERSION ;
                welcome_msg.length = L_ERR_VERSION ;
                if( display_fct != NULL )
                        display_fct( &welcome_msg );
                return(BAD_VERSION) ;
        }
        return(OK) ;
}

%%END%%
mv ./Makefile.distrib ./Makefile
echo Type \'make\' to build the library and the demo programmes.
echo \(after having edited Makefile on SOLARIS 2.x systems\)
exit
