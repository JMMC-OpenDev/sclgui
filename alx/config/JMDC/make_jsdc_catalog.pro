PRO MAKE_JSDC_CATALOG
@ jsdc_define_common.pro
;
  X=FINDGEN(17)*(!PI*2./16.) & USERSYM, 0.75*COS(X), 0.75*SIN(X), /FILL

; correction of database for silly magnitudes
   S=WHERE(DATA_C.B GT 20 OR DATA_C.B LT -2., COUNT) & if(count gt 0) then DATA_C[S].B=SQRT(-1) 
   S=WHERE(DATA_C.V GT 20 OR DATA_C.V LT -2., COUNT) & if(count gt 0) then DATA_C[S].V=SQRT(-1) 
   S=WHERE(DATA_C.I GT 20 OR DATA_C.I LT -2., COUNT) & if(count gt 0) then DATA_C[S].I=SQRT(-1) 
   S=WHERE(DATA_C.R GT 20 OR DATA_C.R LT -2., COUNT) & if(count gt 0) then DATA_C[S].R=SQRT(-1) 

; Initialize parameters & arrays
  MAG_C=[TRANSPOSE(DATA_C.B),TRANSPOSE(DATA_C.V),TRANSPOSE(DATA_C.ICOUS),TRANSPOSE(DATA_C.J),TRANSPOSE(DATA_C.H),TRANSPOSE(DATA_C.K),TRANSPOSE(DATA_C.L),TRANSPOSE(DATA_C.M),TRANSPOSE(DATA_C.N)]
  EMAG_C=[TRANSPOSE(DATA_C.E_B),TRANSPOSE(DATA_C.E_V),TRANSPOSE(DATA_C.E_ICOUS),TRANSPOSE(DATA_C.E_J),TRANSPOSE(DATA_C.E_H),TRANSPOSE(DATA_C.E_K),TRANSPOSE(DATA_C.E_L),TRANSPOSE(DATA_C.E_M),TRANSPOSE(DATA_C.E_N)]
  LUMCLASS_C=DATA_C.LUM_CLASS & SPTYPE_C=DATA_C.COLOR_TABLE_INDEX & MAG_C=TRANSPOSE(MAG_C) & EMAG_C=ABS(TRANSPOSE(EMAG_C))
  NSTAR_C=N_ELEMENTS(MAG_C[*,0]) 
  DIAM_C=DBLARR(NSTAR_C,NCOLORS)
  EDIAM_C=DIAM_C & DMEAN_C=DBLARR(NSTAR_C) & EDMEAN_C=DMEAN_C & RES_C=DBLARR(NSTAR_C,NCOLORS)-100 
  CHI2_DS=DBLARR(NSTAR_C) 

; correction of database from absent photometric errors on b and v
; (very bright stars?). Update back data_c to make these errors appear
; in the JSDC.
  A=EMAG_C[*,0:1] & VVVVV=MAG_C[*,0:1] & S=WHERE(~FINITE(A) and VVVVV LT 3.0, COUNT) & if(count gt 0) then begin
     A[S]=0.1 & EMAG_C[*,0:1]=A ; magnitude min error correction
     DATA_C.E_B=EMAG_C[*,0]
     DATA_C.E_V=EMAG_C[*,1]
  end

; correction of database from too low photometric errors on b and v
  A=EMAG_C[*,0:1] & S=WHERE( A LT EMAG_MIN , COUNT) & if(count gt 0) then A[S]=EMAG_MIN & EMAG_C[*,0:1]=A ; magnitude min error correction

; Select "good" catalog stars
  Q=TOTAL(MAG_C[*,USEDBANDS],2) & P=TOTAL(EMAG_C[*,USEDBANDS],2) & W=WHERE(FINITE(Q) AND FINITE(P))
;IF (LUM_CLASSES EQ 0) THEN GOOD_C=WHERE(LUMCLASS_C(W) NE -1 AND SPTYPE_C(W) NE -1)
;IF (LUM_CLASSES EQ 0) THEN GOOD_C=WHERE(LUMCLASS_C(W) EQ -1 AND SPTYPE_C(W) NE -1)
  IF (LUM_CLASSES EQ 0) THEN GOOD_C=WHERE(SPTYPE_C[W] NE -1 and sptype_c[w]/4. GE 12 AND sptype_c[w]/4. LE 64)
  IF (LUM_CLASSES NE 0) THEN GOOD_C=WHERE(LUMCLASS_C[W] EQ LUM_CLASSES AND SPTYPE_C[W] NE -1)
  IF (LUM_CLASSES EQ 13) THEN GOOD_C=WHERE((LUMCLASS_C[W] EQ 1 OR LUMCLASS_C[W] EQ 3) AND SPTYPE_C[W] NE -1) 
  SPTYPE_C=DOUBLE(SPTYPE_C) & GOOD_C=W[GOOD_C] & NS=LONG(N_ELEMENTS(GOOD_C)) ; & MAG_C(GOOD_C,0)=MAG_C(GOOD_C,0)-0.02

; normalize JHK error on max JHK error.
  FOR N=0,NSTAR_C-1 do EMAG_C[N,JBAND]=MAX(EMAG_C[N,JBAND])

; Compute modeled diameters & errors for all bands
  FOR II=0, NCOLORS-1 DO BEGIN
     MT=MCOV_POL[II*(DEG+1):(II+1)*(DEG+1)-1,II*(DEG+1):(II+1)*(DEG+1)-1] 
     FOR JJ=0L, NS-1 DO BEGIN
        KK=GOOD_C[JJ] & A=MAG_C[KK,IBAND[II]] & B=MAG_C[KK,JBAND[II]] & C=EMAG_C[KK,IBAND[II]] & D=EMAG_C[KK,JBAND[II]]
        DIAM_C[KK,II]=0.2*CJ[II]*A-0.2*CI[II]*B+TOTAL(PARAMS[II,*]*SPTYPE_C[KK]^DINDGEN(DEG+1))
        EDIAM_C[KK,II]=SQRT(0.04*CJ[II]^2*C^2+0.04*CI[II]^2*D^2+TRANSPOSE(SPTYPE_C[KK]^DINDGEN(DEG+1))#MT#(SPTYPE_C[KK]^DINDGEN(DEG+1)))
     ENDFOR
  ENDFOR
; Compute mean modeled diameters & errors
  MAT1=0.2*CJ#TRANSPOSE(0.2*CJ) & MAT2=0.2*CI#TRANSPOSE(0.2*CI)  & MAT3=0.2*CI#TRANSPOSE(0.2*CJ) & DCOV_OC=DBLARR(NCOLORS,NCOLORS,NS)
  FOR LL1=0, NCOLORS-1 DO BEGIN
     Q=EMAG_C[GOOD_C,IBAND[LL1]] & R=EMAG_C[GOOD_C,JBAND[LL1]]
     FOR LL2=0, NCOLORS-1 DO BEGIN
        IF (JBAND[LL1] EQ JBAND[LL2]) THEN DCOV_OC[LL1,LL2,*]=MAT1[LL1,LL2]*Q^2+MAT2[LL1,LL2]*R^2 ELSE DCOV_OC[LL1,LL2,*]=MAT1[LL1,LL2]*Q^2
;        IF (IBAND[LL1] EQ IBAND[LL2] AND JBAND[LL1] EQ JBAND[LL2]) THEN DCOV_OC[LL1,LL2,*]=MAT1[LL1,LL2]*Q^2+MAT2[LL1,LL2]*R^2
 ;       IF (IBAND[LL1] EQ IBAND[LL2] AND JBAND[LL1] NE JBAND[LL2]) THEN DCOV_OC[LL1,LL2,*]=MAT1[LL1,LL2]*Q^2
        ; IBAND[LL1] ne IBAND[LL2] always false!
        ;IF (IBAND[LL1] NE IBAND[LL2] AND JBAND[LL1] EQ JBAND[LL2]) THEN DCOV_OC[LL1,LL2,*]=MAT2[LL1,LL2]*R^2
        ;IF (IBAND[LL1] NE IBAND[LL2] AND JBAND[LL1] NE JBAND[LL2]) THEN DCOV_OC[LL1,LL2,*]=0
     ENDFOR
  ENDFOR
  FOR II=0L, NS-1 DO BEGIN
     FOR JJ=0, NCOLORS-1 DO BEGIN
        FOR KK=0, NCOLORS-1 DO BEGIN
           FOR Z=0, DEG DO BEGIN
              FOR W=0, DEG DO BEGIN
                 DCOV_OC[KK,JJ,II]=DCOV_OC[KK,JJ,II]+SPTYPE_C[GOOD_C[II]]^Z*SPTYPE_C[GOOD_C[II]]^W*MCOV_POL[(DEG+1)*JJ+Z,(DEG+1)*KK+W]
              ENDFOR
           ENDFOR
        ENDFOR
     ENDFOR
  ENDFOR
  FOR II=0L, NS-1 DO BEGIN
     C=DCOV_OC[*,*,II] & B=INVERT(C,/DOUBLE,STATUS) & A=TOTAL(B) & IF (STATUS NE 0) THEN PRINT,"Error "+strtrim(status,2)+" at line "+strtrim(((SCOPE_TRACEBACK(/STRUCT))[-1]).LINE,2)+" in procedure "+((SCOPE_TRACEBACK(/STRUCT))[-1]).routine
     DMEAN_C[GOOD_C[II]]=TOTAL(B#TOTAL(DIAM_C[GOOD_C[II],*],1))/A & EDMEAN_C[GOOD_C[II]]=1/SQRT(A) 
     DIF=DMEAN_C[GOOD_C[II]]-DIAM_C[GOOD_C[II],*] & RES_C[GOOD_C[II],*]=DIF/SQRT((EDMEAN_C[GOOD_C[II]]^2+EDIAM_C[GOOD_C[II],*]^2))
     CHI2_DS[GOOD_C[II]]=DIF#B#TRANSPOSE(DIF)/NCOLORS
  ENDFOR

; Plot histograms
  !P.MULTI=[0,3,2]
  BIN=0.2 & HHM=HISTOGRAM(RES_C[GOOD_C,*],BINSIZE=BIN,LOCATIONS=XXM) & XXM=XXM+BIN/2. & RESM=GAUSSFIT(XXM,HHM,NTERMS=3,ZM)
  PRINTF,UNITLOG,'Catalog:'
  PRINTF,UNITLOG,'LUM_CLASSES ='+strtrim(LUM_CLASSES,2)+', NSTAR='+strtrim(NS,2)+', CHI2_DS ='+strtrim(MEAN(CHI2_DS[GOOD_C]),2)
  IF (DOPRINT) THEN PRINTF,UNITLOG,ZM[0],ZM[1],ZM[2]
  FOR N=0, NCOLORS-1 DO BEGIN &$
     HH=HISTOGRAM(RES_C[GOOD_C,N],BINSIZE=BIN,LOCATIONS=XX) & XX=XX+BIN/2. & RES=GAUSSFIT(XX,HH,NTERMS=3,Z) &$
     PLOT,XX,HH,PSYM=10,XRANGE=[-5,5],XSTYLE=1 & OPLOT,XX,RES,COLOR=65000 & IF (DOPRINT) THEN PRINTF,UNITLOG,Z &$
  ENDFOR
  PLOT,XXM,HHM,PSYM=10,XRANGE=[-5,5],XSTYLE=1 & OPLOT,XXM,RESM,COLOR=1000
  !P.MULTI=0

rep='' & if (dowait) then READ, 'press any key to continue', rep

; Plot results
  ZZ=DINDGEN(100)/10-5
  !P.MULTI=[0,2,2]
  FOR N=0, NCOLORS-1 DO BEGIN &$
     PLOT,DMEAN_C[GOOD_C],DIAM_C[GOOD_C,N],PSYM=3 & OPLOT,ZZ,ZZ,COLOR=64000 &$
  ENDFOR
rep='' & if (dowait) then READ, 'press any key to continue', rep


;PLOT,DMEAN_C(GOOD_C),DIAM_C(GOOD_C,0),PSYM=3
;FOR N=0, NCOLORS-1 DO BEGIN
;OPLOT,DMEAN_C(GOOD_C),DIAM_C(GOOD_C,N),PSYM=3 & OPLOT,ZZ,ZZ,COLOR=1000
;ENDFOR
  !P.MULTI=0
; Plot mean diameter errors
;BIN=0.001 & HH=HISTOGRAM(EDMEAN_C(GOOD_C)*ALOG(10.),BINSIZE=BIN,LOCATIONS=XX) & XX=XX+BIN/2
;PLOT,XX,HH,PSYM=10,XRANGE=[0,0.03],XSTYLE=1 & RR=SQRT(TOTAL(DIAM_C(GOOD_C,*)^2,2)/NS-(TOTAL(DIAM_C(GOOD_C,*),2)/NS)^2)*ALOG(10.)
;BIN=0.001 & HH=HISTOGRAM(RR*ALOG(10)/SQRT(FLOAT(NCOLORS)),BINSIZE=BIN,LOCATIONS=XX) & XX=XX+BIN/2 & OPLOT,XX,HH,PSYM=10,COLOR=64000
;IF (DOPRINT) THEN PRINTF,UNITLOG,MEDIAN(EDMEAN_C(GOOD_C))*ALOG(10),MEDIAN(RR)*ALOG(10)/SQRT(FLOAT(NCOLORS))
;
;  estimate errors due to polynom only (test of good health)
; create sptypes 0 to NSPECTRALTYPES-1
PRINTF,UNITLOG,"Health Check: Minimum relative errors due to polynoms only:"
  MAT1=0.2*CJ#TRANSPOSE(0.2*CJ) & MAT2=0.2*CI#TRANSPOSE(0.2*CI)  & MAT3=0.2*CI#TRANSPOSE(0.2*CJ) 
  MYSPT=DINDGEN(NSPECTRALTYPES)
  FOR II=0L, NSPECTRALTYPES-1 DO BEGIN
     DCOV_OC_TEST=DBLARR(NCOLORS,NCOLORS)
     FOR LL1=0, NCOLORS-1 DO BEGIN
        Q=1.D-4 & R=1.D-4
        FOR LL2=0, NCOLORS-1 DO BEGIN
           IF (JBAND[LL1] EQ JBAND[LL2]) THEN DCOV_OC_TEST[LL1,LL2]=MAT1[LL1,LL2]*Q^2+MAT2[LL1,LL2]*R^2 ELSE DCOV_OC_TEST[LL1,LL2]=MAT1[LL1,LL2]*Q^2
        ENDFOR
     ENDFOR
     FOR JJ=0, NCOLORS-1 DO BEGIN
        FOR KK=0, NCOLORS-1 DO BEGIN
           FOR Z=0, DEG DO BEGIN
              FOR W=0, DEG DO BEGIN
                 DCOV_OC_TEST[KK,JJ]=DCOV_OC_TEST[KK,JJ]+MYSPT[II]^Z*MYSPT[II]^W*MCOV_POL[(DEG+1)*JJ+Z,(DEG+1)*KK+W]
              ENDFOR
           ENDFOR
        ENDFOR
     ENDFOR
     C=DCOV_OC_TEST & B=INVERT(C,/DOUBLE,STATUS) & A=TOTAL(B) & IF (STATUS NE 0) THEN PRINT,"Error "+strtrim(status,2)+" at line "+strtrim(((SCOPE_TRACEBACK(/STRUCT))[-1]).LINE,2)+" in procedure "+((SCOPE_TRACEBACK(/STRUCT))[-1]).routine
     EDMEAN_C_TEST=1/SQRT(A)
     PRINTF,UNITLOG,II,EDMEAN_C_TEST*ALOG(10.0)
  ENDFOR

  RETURN
END
